# 5. í”„ë¡œì„¸ìŠ¤ ê°„ í†µì‹  (IPC)

## 5.1 íŒŒì´í”„ (`pipe()`, `mkfifo()`)

### 1. ê°œìš”

**íŒŒì´í”„(pipe)**ëŠ” **í”„ë¡œì„¸ìŠ¤ ê°„ í†µì‹ (IPC, Inter-Process Communication)**ì„ ìœ„í•œ ê°€ì¥ ê°„ë‹¨í•˜ê³  íš¨ìœ¨ì ì¸ ë©”ì»¤ë‹ˆì¦˜ ì¤‘ í•˜ë‚˜ë‹¤.

- **í•œ í”„ë¡œì„¸ìŠ¤ì—ì„œ ë°ì´í„°ë¥¼ ì“°ë©´, ë‹¤ë¥¸ í”„ë¡œì„¸ìŠ¤ê°€ ê·¸ ë°ì´í„°ë¥¼ ì½ì„ ìˆ˜ ìˆë‹¤.**
- íŒŒì´í”„ëŠ” **ì»¤ë„ ë²„í¼**ë¥¼ ì´ìš©í•´ ë°ì´í„°ë¥¼ ì„ì‹œ ì €ì¥í•œë‹¤.
- **ë‹¨ë°©í–¥ í†µì‹ ** êµ¬ì¡°ì´ë‹¤. (ì–‘ë°©í–¥ìœ¼ë¡œ ì“°ê³  ì‹¶ìœ¼ë©´ íŒŒì´í”„ ë‘ ê°œ ì‚¬ìš©)

íŒŒì´í”„ëŠ” í¬ê²Œ 2ê°€ì§€ë¡œ ë‚˜ëˆŒ ìˆ˜ ìˆë‹¤:

| ì¢…ë¥˜                           | íŠ¹ì§•                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| **ìµëª… íŒŒì´í”„ (`pipe()`)**     | ë¶€ëª¨-ìì‹ í”„ë¡œì„¸ìŠ¤ ê°„ í†µì‹ ì— ì£¼ë¡œ ì‚¬ìš©ë¨                     |
| **ëª…ëª…ëœ íŒŒì´í”„ (`mkfifo()`)** | ì„œë¡œ ê´€ê³„ ì—†ëŠ” ë…ë¦½ì ì¸ í”„ë¡œì„¸ìŠ¤ ê°„ í†µì‹  ê°€ëŠ¥ (íŒŒì¼ì‹œìŠ¤í…œ ê²½ë¡œë¡œ ì ‘ê·¼ ê°€ëŠ¥) |

------

### 2. `pipe()` â€” ìµëª… íŒŒì´í”„

#### 2.1 í•¨ìˆ˜ ì›í˜•

```
#include <unistd.h>

int pipe(int pipefd[2]);
```

- `pipefd[0]` â†’ **ì½ê¸°ìš©** file descriptor (read end)
- `pipefd[1]` â†’ **ì“°ê¸°ìš©** file descriptor (write end)

#### ë°˜í™˜ê°’

- ì„±ê³µ ì‹œ 0, ì‹¤íŒ¨ ì‹œ -1

------

#### 2.2 ê¸°ë³¸ ì‚¬ìš© íŒ¨í„´

```
Parent creates pipe()
fork()

Parent:
    writes to pipefd[1]

Child:
    reads from pipefd[0]
```

- fork í›„ ë¶€ëª¨ì™€ ìì‹ì´ **ê°ê° ë‹¤ë¥¸ ìª½ì˜ íŒŒì´í”„ ëë§Œ ì‚¬ìš©**í•˜ë„ë¡ ì„¤ì • â†’ ë‚˜ë¨¸ì§€ fdëŠ” ë‹«ì•„ì£¼ëŠ” ê²Œ ì¢‹ìŒ.

------

#### 2.3 ì˜ˆì œ

```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

int main() {
    int pipefd[2];
    char buffer[128];

    if (pipe(pipefd) == -1) {
        perror("pipe");
        return 1;
    }

    pid_t pid = fork();

    if (pid == -1) {
        perror("fork");
        return 1;
    } else if (pid == 0) {
        // Child process â†’ read
        close(pipefd[1]);  // write end ë‹«ê¸°
        read(pipefd[0], buffer, sizeof(buffer));
        printf("Child received: %s\n", buffer);
        close(pipefd[0]);
    } else {
        // Parent process â†’ write
        close(pipefd[0]);  // read end ë‹«ê¸°
        const char *msg = "Hello from parent!";
        write(pipefd[1], msg, strlen(msg) + 1);
        close(pipefd[1]);
    }

    return 0;
}
```

#### ì‹¤í–‰ ê²°ê³¼

```
Child received: Hello from parent!
```

------

### 3. `mkfifo()` â€” ëª…ëª…ëœ íŒŒì´í”„ (FIFO)

#### 3.1 ê°œë…

- íŒŒì¼ ì‹œìŠ¤í…œ ìƒì— **FIFO special file**ì„ ìƒì„±
- ì´ë¦„ì„ í†µí•´ ì„œë¡œ ë‹¤ë¥¸ í”„ë¡œì„¸ìŠ¤ê°€ FIFOë¥¼ í†µí•´ í†µì‹  ê°€ëŠ¥
- ì»¤ë„ ë‚´ë¶€ì—ì„œ íŒŒì´í”„ì²˜ëŸ¼ ë™ì‘ (ë©”ëª¨ë¦¬ ë²„í¼ ì‚¬ìš©)

------

#### 3.2 í•¨ìˆ˜ ì›í˜•

```
#include <sys/types.h>
#include <sys/stat.h>

int mkfifo(const char *pathname, mode_t mode);
```

- `pathname`: ìƒì„±í•  FIFO íŒŒì¼ ê²½ë¡œ
- `mode`: ì ‘ê·¼ ê¶Œí•œ (ex. `0666`)

#### ë°˜í™˜ê°’

- ì„±ê³µ ì‹œ 0, ì‹¤íŒ¨ ì‹œ -1

------

#### 3.3 ì‚¬ìš© íŒ¨í„´

```
mkfifo myfifo
```

```
# í„°ë¯¸ë„1
cat myfifo

# í„°ë¯¸ë„2
echo "hello via fifo" > myfifo
```

â†’ catì´ **FIFOì—ì„œ ë°ì´í„° ì½ìŒ** â†’ ì¶œë ¥ë¨

------

#### 3.4 C ì½”ë“œ ì˜ˆì œ

**writer.c**

```
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/stat.h>
#include <string.h>

int main() {
    const char *fifo_path = "myfifo";

    mkfifo(fifo_path, 0666);

    int fd = open(fifo_path, O_WRONLY);
    const char *msg = "Hello via FIFO!";
    write(fd, msg, strlen(msg) + 1);
    close(fd);

    return 0;
}
```

**reader.c**

```
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/stat.h>

int main() {
    const char *fifo_path = "myfifo";

    int fd = open(fifo_path, O_RDONLY);
    char buffer[128];
    read(fd, buffer, sizeof(buffer));
    printf("Reader received: %s\n", buffer);
    close(fd);

    return 0;
}
```

#### ì‹¤í–‰ ìˆœì„œ

```
gcc writer.c -o writer
gcc reader.c -o reader

./reader    # ë¨¼ì € ì‹¤í–‰ â†’ read ëŒ€ê¸°
./writer    # ì‹¤í–‰ â†’ writerê°€ msg ì“°ê³  ì¢…ë£Œ
```

#### ê²°ê³¼

```
Reader received: Hello via FIFO!
```

------

### 4. `pipe()` vs `mkfifo()`

| êµ¬ë¶„      | `pipe()`                                     | `mkfifo()`                           |
| --------- | -------------------------------------------- | ------------------------------------ |
| ìƒì„± ëŒ€ìƒ | í”„ë¡œì„¸ìŠ¤ ê°„ fd ë°°ì—´                          | íŒŒì¼ ì‹œìŠ¤í…œ ë‚´ FIFO íŒŒì¼             |
| í†µì‹  ë²”ìœ„ | ë¶€ëª¨-ìì‹ ë“± **fork()ë¡œ ì—°ê²°ëœ í”„ë¡œì„¸ìŠ¤**    | **ì™„ì „íˆ ë…ë¦½ì ì¸ í”„ë¡œì„¸ìŠ¤** ê°„ ê°€ëŠ¥ |
| ì§€ì†ì„±    | í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ ì‹œ ì‚¬ë¼ì§                      | FIFO íŒŒì¼ë¡œ ê³„ì† ì¡´ì¬                |
| ì‚¬ìš© ì˜ˆ   | ê°„ë‹¨í•œ IPC (ì‰˜ íŒŒì´í”„ë¼ì¸, í”„ë¡œì„¸ìŠ¤ ê°„ í†µì‹ ) | ë°ëª¬, ì„œë²„-í´ë¼ì´ì–¸íŠ¸ IPC ë“±         |

------

### 5. ê²°ë¡  ğŸš€

- `pipe()`ëŠ” **í”„ë¡œì„¸ìŠ¤ ê°„ ë¹ ë¥¸ ë‹¨ë°©í–¥ í†µì‹ **ì— ìœ ìš©.
- `mkfifo()`ëŠ” **ë…ë¦½ í”„ë¡œì„¸ìŠ¤ ê°„ IPC**ì— ìœ ìš©í•˜ë©° **ì‰˜ì—ì„œ ì‚¬ìš©í•˜ê¸° ì‰½ë‹¤**.
- `pipe()`ì™€ `mkfifo()`ëŠ” ì»¤ë„ì´ ì œê³µí•˜ëŠ” **ë²„í¼ ê¸°ë°˜ ìŠ¤íŠ¸ë¦¼**ì´ë©°, ì‚¬ìš© ì‹œ **ì •í™•í•œ fd ê´€ë¦¬**ê°€ ì¤‘ìš”í•˜ë‹¤.

## 5.2 ë©”ì‹œì§€ í, ì„¸ë§ˆí¬ì–´ (`System V`)

### 1. ê°œìš”

**System V IPC (Inter-Process Communication)**ëŠ” ë¦¬ëˆ…ìŠ¤ì—ì„œ ì œê³µí•˜ëŠ” **ì „í†µì ì¸ IPC ë©”ì»¤ë‹ˆì¦˜** ì¤‘ í•˜ë‚˜ë‹¤.
 ê°€ì¥ ëŒ€í‘œì ì¸ 3ê°€ì§€ ê¸°ëŠ¥ì€:

| ê¸°ëŠ¥              | ëª©ì                                 |
| ----------------- | ----------------------------------- |
| **Message Queue** | **í”„ë¡œì„¸ìŠ¤ ê°„ ë©”ì‹œì§€ êµí™˜**         |
| **Semaphore**     | **í”„ë¡œì„¸ìŠ¤ ê°„ ë™ê¸°í™” ë° ìƒí˜¸ ë°°ì œ** |
| **Shared Memory** | **í”„ë¡œì„¸ìŠ¤ ê°„ ë©”ëª¨ë¦¬ ì˜ì—­ ê³µìœ **    |

ì´ë²ˆì—ëŠ” ê·¸ì¤‘ **Message Queue, Semaphore** ë¥¼ ë‹¤ë£¬ë‹¤.
 (Shared MemoryëŠ” 5.3ì—ì„œ ë³´ê²Œ ë  ë‚´ìš©)

------

### ğŸ“Œ Part 1: Message Queue (ë©”ì‹œì§€ í)

### 2. Message Queueë€?

- ì»¤ë„ ë‚´ë¶€ì— **ë©”ì‹œì§€ í ê°ì²´**ë¥¼ ë§Œë“¤ê³ , í”„ë¡œì„¸ìŠ¤ë¼ë¦¬ **ë©”ì‹œì§€ êµ¬ì¡°ì²´** ë‹¨ìœ„ë¡œ ë°ì´í„°ë¥¼ ì£¼ê³ ë°›ìŒ.
- ê° ë©”ì‹œì§€ì— **í˜•(type)**ì´ ìˆì–´ ë©”ì‹œì§€ ë¶„ë¥˜ ê°€ëŠ¥.

#### ì¥ì 

âœ… ë¹„ë™ê¸° ì „ì†¡ ê°€ëŠ¥ (senderì™€ receiver ë…ë¦½ ì‹¤í–‰ ê°€ëŠ¥)
 âœ… ë©”ì‹œì§€ì˜ êµ¬ì¡°í™” ê°€ëŠ¥ (`struct msgbuf` ì‚¬ìš©)
 âœ… ì»¤ë„ì´ ë²„í¼ ê´€ë¦¬

------

### 3. ê´€ë ¨ í•¨ìˆ˜

```
#include <sys/ipc.h>
#include <sys/msg.h>
```

| í•¨ìˆ˜       | ì—­í•                      |
| ---------- | ------------------------ |
| `msgget()` | ë©”ì‹œì§€ í ìƒì„± / ì ‘ê·¼    |
| `msgsnd()` | ë©”ì‹œì§€ ë³´ë‚´ê¸°            |
| `msgrcv()` | ë©”ì‹œì§€ ë°›ê¸°              |
| `msgctl()` | ë©”ì‹œì§€ í ì œì–´ (ì‚­ì œ ë“±) |

------

### 4. ë©”ì‹œì§€ êµ¬ì¡°ì²´

```
struct msgbuf {
    long mtype;        // ë©”ì‹œì§€ íƒ€ì… (ì–‘ìˆ˜)
    char mtext[128];   // ë©”ì‹œì§€ ë³¸ë¬¸
};
```

- `mtype` â†’ ë©”ì‹œì§€ ì¢…ë¥˜ ì‹ë³„ìš© â†’ ìˆ˜ì‹  ì‹œ íŠ¹ì • typeë§Œ ë°›ì„ ìˆ˜ ìˆìŒ.
- `mtext` â†’ ë©”ì‹œì§€ ë‚´ìš©.

------

### 5. ì˜ˆì œ: ë©”ì‹œì§€ í ì†¡/ìˆ˜ì‹ 

#### ì†¡ì‹  í”„ë¡œê·¸ë¨ (sender.c)

```
#include <stdio.h>
#include <stdlib.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <string.h>

struct msgbuf {
    long mtype;
    char mtext[128];
};

int main() {
    key_t key = ftok("msgqueuefile", 65);
    int msgid = msgget(key, 0666 | IPC_CREAT);

    struct msgbuf message;
    message.mtype = 1;
    strcpy(message.mtext, "Hello via Message Queue!");

    msgsnd(msgid, &message, sizeof(message.mtext), 0);

    printf("Sent: %s\n", message.mtext);

    return 0;
}
```

------

#### ìˆ˜ì‹  í”„ë¡œê·¸ë¨ (receiver.c)

```
#include <stdio.h>
#include <stdlib.h>
#include <sys/ipc.h>
#include <sys/msg.h>

struct msgbuf {
    long mtype;
    char mtext[128];
};

int main() {
    key_t key = ftok("msgqueuefile", 65);
    int msgid = msgget(key, 0666 | IPC_CREAT);

    struct msgbuf message;
    msgrcv(msgid, &message, sizeof(message.mtext), 1, 0);

    printf("Received: %s\n", message.mtext);

    // ë©”ì‹œì§€ í ì‚­ì œ
    msgctl(msgid, IPC_RMID, NULL);

    return 0;
}
```

------

#### ì‹¤í–‰ ìˆœì„œ

```
touch msgqueuefile
gcc sender.c -o sender
gcc receiver.c -o receiver

./sender
./receiver
```

### ê²°ê³¼ ì˜ˆì‹œ

```
Sent: Hello via Message Queue!
Received: Hello via Message Queue!
```

------

### ğŸ“Œ Part 2: Semaphore (ì„¸ë§ˆí¬ì–´)

### 1. Semaphoreë€?

- **í”„ë¡œì„¸ìŠ¤ ê°„ ë™ê¸°í™”/ìƒí˜¸ë°°ì œ**ë¥¼ ìœ„í•œ ì¹´ìš´í„°.
- ì»¤ë„ ë‚´ì— ì¡´ì¬í•˜ë©° í”„ë¡œì„¸ìŠ¤ë“¤ì´ ì›ìì ìœ¼ë¡œ ê°’ì„ ì¡°ì‘ ê°€ëŠ¥.

#### ì‚¬ìš© ì˜ˆ

âœ… ì„ê³„êµ¬ì—­ ë³´í˜¸ (Critical Section)
 âœ… ìƒì‚°ì-ì†Œë¹„ì ë¬¸ì œ í•´ê²°
 âœ… í”„ë¡œì„¸ìŠ¤ ê°„ ì‹¤í–‰ ìˆœì„œ ì œì–´

------

### 2. ê´€ë ¨ í•¨ìˆ˜

```
#include <sys/ipc.h>
#include <sys/sem.h>
```

| í•¨ìˆ˜       | ì—­í•                                   |
| ---------- | ------------------------------------- |
| `semget()` | ì„¸ë§ˆí¬ì–´ ì„¸íŠ¸ ìƒì„± / ì ‘ê·¼             |
| `semop()`  | ì„¸ë§ˆí¬ì–´ ì¡°ì‘ (P/V ì—°ì‚°)              |
| `semctl()` | ì„¸ë§ˆí¬ì–´ ìƒíƒœ ì œì–´ (ê°’ ì„¤ì •, ì‚­ì œ ë“±) |

------

### 3. ê¸°ë³¸ êµ¬ì¡°

- `semget()` â†’ ì„¸ë§ˆí¬ì–´ ID íšë“
- `semctl()` â†’ ì´ˆê¸°ê°’ ì„¤ì •
- `semop()` â†’ P ì—°ì‚°(ì ê¸ˆ), V ì—°ì‚°(í•´ì œ) ì‹¤í–‰

------

### 4. ì˜ˆì œ: ì„¸ë§ˆí¬ì–´ ë™ê¸°í™”

#### ê³µí†µ í—¤ë”

```
#include <sys/ipc.h>
#include <sys/sem.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

union semun {
    int val;
    struct semid_ds *buf;
    unsigned short *array;
};
```

------

#### producer.c (V ì—°ì‚°: unlock)

```
int main() {
    key_t key = ftok("semfile", 75);
    int semid = semget(key, 1, 0666 | IPC_CREAT);

    union semun u;
    u.val = 0;
    semctl(semid, 0, SETVAL, u);  // ì´ˆê¸°ê°’ 0

    printf("Producer doing work...\n");
    sleep(3);

    // V ì—°ì‚° (sem +1)
    struct sembuf op = {0, 1, 0};
    semop(semid, &op, 1);

    printf("Producer signaled!\n");

    return 0;
}
```

------

#### consumer.c (P ì—°ì‚°: lock)

```
int main() {
    key_t key = ftok("semfile", 75);
    int semid = semget(key, 1, 0666);

    printf("Consumer waiting for semaphore...\n");

    // P ì—°ì‚° (sem -1 â†’ ëŒ€ê¸°)
    struct sembuf op = {0, -1, 0};
    semop(semid, &op, 1);

    printf("Consumer proceeding!\n");

    // ì„¸ë§ˆí¬ì–´ ì‚­ì œ
    semctl(semid, 0, IPC_RMID);

    return 0;
}
```

------

#### ì‹¤í–‰ ìˆœì„œ

```
touch semfile
gcc producer.c -o producer
gcc consumer.c -o consumer

./consumer    # consumer ë¨¼ì € â†’ ì„¸ë§ˆí¬ì–´ ëŒ€ê¸°
./producer    # producer ì‹¤í–‰ â†’ ì„¸ë§ˆí¬ì–´ signal â†’ consumer ì§„í–‰
```

#### ê²°ê³¼

```
Consumer waiting for semaphore...
Producer doing work...
Producer signaled!
Consumer proceeding!
```

------

### ğŸ“Œ ê²°ë¡  ğŸš€

| ê¸°ëŠ¥          | í•µì‹¬ íŠ¹ì§•                                            |
| ------------- | ---------------------------------------------------- |
| Message Queue | í”„ë¡œì„¸ìŠ¤ ê°„ ë©”ì‹œì§€ êµí™˜ (êµ¬ì¡°í™”ëœ ë©”ì‹œì§€ ì „ë‹¬ ê°€ëŠ¥)  |
| Semaphore     | í”„ë¡œì„¸ìŠ¤ ê°„ ë™ê¸°í™” / ì„ê³„êµ¬ì—­ ë³´í˜¸ (ì›ìì  P/V ì—°ì‚°) |

**System V IPC**ëŠ” ê³ ì „ì ì´ì§€ë§Œ ì—¬ì „íˆ ê°•ë ¥í•œ IPC ë©”ì»¤ë‹ˆì¦˜ì´ë©°:

- `pipe()`, `mkfifo()` â†’ ë‹¨ìˆœ ìŠ¤íŠ¸ë¦¼ ì „ë‹¬
- `Message Queue` â†’ êµ¬ì¡°í™”ëœ ë©”ì‹œì§€ ê¸°ë°˜ í†µì‹ 
- `Semaphore` â†’ ë™ê¸°í™” ë° ìƒí˜¸ë°°ì œ
- `Shared Memory` â†’ ê³ ì† ë©”ëª¨ë¦¬ ê³µìœ 

ë¡œ ê°ì ëª©ì ì— ë§ì¶° ì‚¬ìš©í•˜ë©´ ëœë‹¤.
 **POSIX IPC (mq_open, sem_open ë“±)**ëŠ” System Vì˜ í˜„ëŒ€í™”ëœ ëŒ€ì•ˆìœ¼ë¡œë„ ì‚¬ìš©ëœë‹¤.

## 5.3 ê³µìœ  ë©”ëª¨ë¦¬ (`shmget`, `shmat`)

### 1. ê°œìš”

**ê³µìœ  ë©”ëª¨ë¦¬(Shared Memory)**ëŠ” ë¦¬ëˆ…ìŠ¤ì—ì„œ **ê°€ì¥ ë¹ ë¥¸ IPC(Inter-Process Communication)** ë°©ë²• ì¤‘ í•˜ë‚˜ë‹¤.
 ë‹¤ë¥¸ IPC ë°©ë²•ë“¤ì€ **ì»¤ë„ ë²„í¼ë¥¼ ê±°ì³ ë°ì´í„°ë¥¼ ì „ë‹¬**í•˜ì§€ë§Œ, ê³µìœ  ë©”ëª¨ë¦¬ëŠ” **ì—¬ëŸ¬ í”„ë¡œì„¸ìŠ¤ê°€ ë™ì¼í•œ ë©”ëª¨ë¦¬ ì˜ì—­ì„ ì§ì ‘ ì°¸ì¡°**í•œë‹¤.

#### íŠ¹ì§•

âœ… ë§¤ìš° ë¹ ë¦„ (ë©”ëª¨ë¦¬ ì ‘ê·¼ ë¹„ìš© ìˆ˜ì¤€)
 âœ… ëŒ€ìš©ëŸ‰ ë°ì´í„° ê³µìœ  ê°€ëŠ¥
 âœ… ëª…ì‹œì  ë™ê¸°í™” í•„ìš” (ë³„ë„ë¡œ Semaphore ë“± ì‚¬ìš© ê¶Œì¥)

------

### 2. ê´€ë ¨ í•¨ìˆ˜

```
#include <sys/ipc.h>
#include <sys/shm.h>
```

| í•¨ìˆ˜       | ì—­í•                                              |
| ---------- | ------------------------------------------------ |
| `shmget()` | ê³µìœ  ë©”ëª¨ë¦¬ ì„¸ê·¸ë¨¼íŠ¸ ìƒì„± ë˜ëŠ” ì ‘ê·¼              |
| `shmat()`  | ê³µìœ  ë©”ëª¨ë¦¬ë¥¼ í”„ë¡œì„¸ìŠ¤ ì£¼ì†Œ ê³µê°„ì— ì—°ê²° (attach) |
| `shmdt()`  | ê³µìœ  ë©”ëª¨ë¦¬ ì—°ê²° í•´ì œ (detach)                   |
| `shmctl()` | ê³µìœ  ë©”ëª¨ë¦¬ ì •ë³´ ì¡°íšŒ, ì‚­ì œ ë“± ì œì–´              |

------

### 3. ê¸°ë³¸ íë¦„

```
1ï¸âƒ£ Producer:
    shmget() â†’ shmat() â†’ ë©”ëª¨ë¦¬ ì“°ê¸° â†’ shmdt()

2ï¸âƒ£ Consumer:
    shmget() â†’ shmat() â†’ ë©”ëª¨ë¦¬ ì½ê¸° â†’ shmdt()

3ï¸âƒ£ ë§ˆë¬´ë¦¬: shmctl(IPC_RMID) â†’ ê³µìœ  ë©”ëª¨ë¦¬ ì‚­ì œ
```

------

### 4. ê³µìœ  ë©”ëª¨ë¦¬ êµ¬ì¡°

```
key_t key = ftok("shmfile", 65);  // í‚¤ ìƒì„±
int shmid = shmget(key, size, IPC_CREAT | 0666);  // ê³µìœ  ë©”ëª¨ë¦¬ ìƒì„±
void *ptr = shmat(shmid, NULL, 0);  // í”„ë¡œì„¸ìŠ¤ì— attach
```

- ê³µìœ  ë©”ëª¨ë¦¬ëŠ” **í‚¤(key)**ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì ‘ê·¼í•œë‹¤ (`ftok()` ì‚¬ìš© ê°€ëŠ¥).
- `shmat()`ëŠ” ê³µìœ  ë©”ëª¨ë¦¬ë¥¼ **ê°€ìƒ ì£¼ì†Œ ê³µê°„ìœ¼ë¡œ ë§¤í•‘**í•œë‹¤ â†’ ì¼ë°˜ í¬ì¸í„°ì²˜ëŸ¼ ì‚¬ìš© ê°€ëŠ¥.

------

### 5. ì˜ˆì œ: ê³µìœ  ë©”ëª¨ë¦¬ë¥¼ í†µí•œ í”„ë¡œì„¸ìŠ¤ ê°„ ë°ì´í„° ì „ë‹¬

#### Producer (writer.c)

```
#include <stdio.h>
#include <stdlib.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <string.h>

int main() {
    key_t key = ftok("shmfile", 65);  // í‚¤ ìƒì„±
    int shmid = shmget(key, 1024, 0666 | IPC_CREAT);  // ê³µìœ  ë©”ëª¨ë¦¬ ìƒì„±

    char *str = (char *)shmat(shmid, NULL, 0);  // attach
    printf("Write Data: ");
    fgets(str, 1024, stdin);  // ì‚¬ìš©ì ì…ë ¥ì„ ê³µìœ  ë©”ëª¨ë¦¬ì— ì €ì¥

    shmdt(str);  // detach
    return 0;
}
```

------

#### Consumer (reader.c)

```
#include <stdio.h>
#include <stdlib.h>
#include <sys/ipc.h>
#include <sys/shm.h>

int main() {
    key_t key = ftok("shmfile", 65);  // ë™ì¼í•œ í‚¤ ì‚¬ìš©
    int shmid = shmget(key, 1024, 0666);  // ê¸°ì¡´ ê³µìœ  ë©”ëª¨ë¦¬ì— ì ‘ê·¼

    char *str = (char *)shmat(shmid, NULL, 0);  // attach

    printf("Data read from memory: %s\n", str);

    shmdt(str);  // detach
    shmctl(shmid, IPC_RMID, NULL);  // ê³µìœ  ë©”ëª¨ë¦¬ ì‚­ì œ

    return 0;
}
```

------

#### ì‹¤í–‰ ìˆœì„œ

```
touch shmfile
gcc writer.c -o writer
gcc reader.c -o reader

./writer    # ë¨¼ì € ì‹¤í–‰ â†’ ì…ë ¥ ë°ì´í„° ì €ì¥
./reader    # ì´í›„ ì‹¤í–‰ â†’ ë°ì´í„° ì½ê¸° + ê³µìœ  ë©”ëª¨ë¦¬ ì‚­ì œ
```

#### ê²°ê³¼ ì˜ˆì‹œ

```
Write Data: Hello Shared Memory!

Data read from memory: Hello Shared Memory!
```

------

### 6. ì£¼ì˜ ì‚¬í•­

- ê³µìœ  ë©”ëª¨ë¦¬ëŠ” ë§¤ìš° ë¹ ë¥´ì§€ë§Œ, **ë™ê¸°í™”ê°€ í•„ìš”**í•˜ë‹¤.
   â†’ ì—¬ëŸ¬ í”„ë¡œì„¸ìŠ¤ê°€ ë™ì‹œì— ì ‘ê·¼í•˜ë©´ **ë°ì´í„° ì¶©ëŒ ê°€ëŠ¥**
   â†’ ì¼ë°˜ì ìœ¼ë¡œ **Semaphore** ë“±ì„ ê°™ì´ ì‚¬ìš©
- `shmctl(IPC_RMID)` í˜¸ì¶œë¡œ ê³µìœ  ë©”ëª¨ë¦¬ë¥¼ **ëª…ì‹œì ìœ¼ë¡œ ì‚­ì œ**í•´ì•¼ í•œë‹¤.
   â†’ ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ ì‹œìŠ¤í…œì— orphanëœ ê³µìœ  ë©”ëª¨ë¦¬ê°€ ë‚¨ëŠ”ë‹¤ (`ipcs -m` ëª…ë ¹ìœ¼ë¡œ í™•ì¸ ê°€ëŠ¥).

------

### 7. `ipcs`, `ipcrm` ëª…ë ¹ì–´

#### í˜„ì¬ ê³µìœ  ë©”ëª¨ë¦¬ ëª©ë¡ í™•ì¸

```
ipcs -m
```

#### ê³µìœ  ë©”ëª¨ë¦¬ ì‚­ì œ (id í™•ì¸ í›„ ì‚­ì œ)

```
ipcrm -m <shmid>
```

------

### 8. ê²°ë¡  ğŸš€

| ê¸°ëŠ¥       | íŠ¹ì§•                                      |
| ---------- | ----------------------------------------- |
| `shmget()` | ê³µìœ  ë©”ëª¨ë¦¬ ì„¸ê·¸ë¨¼íŠ¸ ìƒì„±/íšë“            |
| `shmat()`  | ê³µìœ  ë©”ëª¨ë¦¬ attach â†’ í¬ì¸í„°ì²˜ëŸ¼ ì‚¬ìš© ê°€ëŠ¥ |
| `shmdt()`  | detach                                    |
| `shmctl()` | ì‚­ì œ, ì •ë³´ ì¡°íšŒ ë“±                        |

**ê³µìœ  ë©”ëª¨ë¦¬**ëŠ” **ë§¤ìš° ë¹ ë¥´ê³  íš¨ìœ¨ì ì¸ IPC ìˆ˜ë‹¨**ì´ë©°,
 **ëŒ€ìš©ëŸ‰ ë°ì´í„° ê³µìœ **, **ë‹¤ì¤‘ í”„ë¡œì„¸ìŠ¤ í˜‘ë ¥ ì‹œìŠ¤í…œ** ë“±ì— í•„ìˆ˜ì ìœ¼ë¡œ ì‚¬ìš©ëœë‹¤.

**ë‹¨ì **ì€ **ëª…ì‹œì  ë™ê¸°í™” í•„ìš”**(ë³´í†µ Semaphoreì™€ ê°™ì´ ì‚¬ìš©).

## 5.4 ì‹œê·¸ë„ê³¼ `kill()`, `signal()`

### 1. ê°œìš”

**ì‹œê·¸ë„(Signal)**ì€ ë¦¬ëˆ…ìŠ¤/ìœ ë‹‰ìŠ¤ì—ì„œ **í”„ë¡œì„¸ìŠ¤ ê°„ ë¹„ë™ê¸°ì  ì´ë²¤íŠ¸ í†µì§€**ë¥¼ ìœ„í•œ ê³ ì „ì ì¸ IPC ë©”ì»¤ë‹ˆì¦˜ì´ë‹¤.

- ì‹œê·¸ë„ì€ ì»¤ë„ì´ í”„ë¡œì„¸ìŠ¤ì—ê²Œ **"ë¬´ì–¸ê°€ê°€ ë°œìƒí–ˆë‹¤"**ëŠ” ì•Œë¦¼ì„ ë³´ë‚´ëŠ” ë°©ì‹ì´ë‹¤.
- ì˜ˆë¥¼ ë“¤ì–´, í”„ë¡œì„¸ìŠ¤ê°€ **Ctrl+C**ë¡œ ì¢…ë£Œë  ë•Œ ë‚´ë¶€ì ìœ¼ë¡œ **SIGINT ì‹œê·¸ë„**ì´ ì „ì†¡ëœë‹¤.

#### ì‹œê·¸ë„ ì‚¬ìš© ì˜ˆì‹œ

âœ… í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ ìš”ì²­ (kill ëª…ë ¹ì–´)
 âœ… ì•ŒëŒ/íƒ€ì´ë¨¸ ì‹œê·¸ë„
 âœ… ì‚¬ìš©ì ì •ì˜ ì‹œê·¸ë„ â†’ í”„ë¡œì„¸ìŠ¤ ì œì–´/ì´ë²¤íŠ¸ í†µì§€
 âœ… IPC êµ¬í˜„ì—ì„œ ì‚¬ìš© ê°€ëŠ¥

------

### 2. ì£¼ìš” ì‹œê·¸ë„ ì¢…ë¥˜

| ì‹œê·¸ë„               | ì˜ë¯¸                                        |
| -------------------- | ------------------------------------------- |
| `SIGINT`             | ì¸í„°ëŸ½íŠ¸ (Ctrl+C)                           |
| `SIGTERM`            | ì •ìƒ ì¢…ë£Œ ìš”ì²­                              |
| `SIGKILL`            | ê°•ì œ ì¢…ë£Œ (ë¬´ì¡°ê±´ ì¢…ë£Œ)                     |
| `SIGSTOP`            | í”„ë¡œì„¸ìŠ¤ ì¼ì‹œ ì •ì§€                          |
| `SIGCONT`            | ì •ì§€ëœ í”„ë¡œì„¸ìŠ¤ ì¬ê°œ                        |
| `SIGALRM`            | ì•ŒëŒ íƒ€ì´ë¨¸ ì‹œê·¸ë„                          |
| `SIGUSR1`, `SIGUSR2` | ì‚¬ìš©ì ì •ì˜ ì‹œê·¸ë„ (IPC ë“±ì—ì„œ ë§ì´ ì‚¬ìš©ë¨) |

â†’ `man 7 signal` ëª…ë ¹ì–´ë¡œ ì „ì²´ ì‹œê·¸ë„ ëª©ë¡ í™•ì¸ ê°€ëŠ¥.

------

### 3. ê´€ë ¨ í•¨ìˆ˜

#### `kill()` â€” ì‹œê·¸ë„ ë³´ë‚´ê¸°

```
#include <signal.h>

int kill(pid_t pid, int sig);
```

- `pid`: ëŒ€ìƒ í”„ë¡œì„¸ìŠ¤ ID
- `sig`: ë³´ë‚¼ ì‹œê·¸ë„ ë²ˆí˜¸

#### `signal()` â€” ì‹œê·¸ë„ í•¸ë“¤ëŸ¬ ì„¤ì •

```
#include <signal.h>

void (*signal(int signum, void (*handler)(int)))(int);
```

- `signum`: ì„¤ì •í•  ì‹œê·¸ë„ ë²ˆí˜¸
- `handler`: ì‹œê·¸ë„ ë°œìƒ ì‹œ í˜¸ì¶œë  í•¨ìˆ˜ í¬ì¸í„°

------

### 4. ì˜ˆì œ: ì‹œê·¸ë„ í•¸ë“¤ë§

#### 4.1 ì‹œê·¸ë„ í•¸ë“¤ëŸ¬ ë“±ë¡

```
#include <stdio.h>
#include <signal.h>
#include <unistd.h>

void sig_handler(int signo) {
    printf("Received signal %d\n", signo);
}

int main() {
    signal(SIGINT, sig_handler);  // Ctrl+C ì²˜ë¦¬
    signal(SIGUSR1, sig_handler); // ì‚¬ìš©ì ì •ì˜ ì‹œê·¸ë„

    printf("PID: %d\n", getpid());

    while (1) {
        printf("Waiting for signal...\n");
        sleep(2);
    }

    return 0;
}
```

------

### 4.2 ì‹¤í–‰ ì˜ˆì‹œ

```
gcc signal_test.c -o signal_test
./signal_test
```

```
PID: 12345
Waiting for signal...
Waiting for signal...
```

â†’ ë‹¤ë¥¸ í„°ë¯¸ë„ì—ì„œ:

```
kill -SIGUSR1 12345
kill -SIGINT 12345
```

â†’ ì¶œë ¥ ì˜ˆì‹œ:

```
Received signal 10
Received signal 2
```

------

### 5. `kill` ëª…ë ¹ì–´ ì‚¬ìš©ë²•

#### í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ

```
kill -SIGTERM <pid>   # ì •ìƒ ì¢…ë£Œ ìš”ì²­ (ê¸°ë³¸ê°’)
kill -9 <pid>         # SIGKILL (ë¬´ì¡°ê±´ ì¢…ë£Œ)
kill -SIGSTOP <pid>   # í”„ë¡œì„¸ìŠ¤ ì •ì§€
kill -SIGCONT <pid>   # í”„ë¡œì„¸ìŠ¤ ì¬ê°œ
```

------

### 6. ì£¼ì˜ ì‚¬í•­

- `SIGKILL`ì€ í”„ë¡œì„¸ìŠ¤ê°€ **catch ë¶ˆê°€ / block ë¶ˆê°€ / ignore ë¶ˆê°€** â†’ ì»¤ë„ì´ ë¬´ì¡°ê±´ ì¢…ë£Œ
- `SIGSTOP`ë„ ë§ˆì°¬ê°€ì§€ë¡œ í”„ë¡œì„¸ìŠ¤ê°€ **ë°˜ì‘ ë¶ˆê°€** â†’ ê°•ì œ ì •ì§€ë¨
- ì¼ë°˜ì ì¸ ì‹œê·¸ë„ë“¤ì€ `signal()` ë˜ëŠ” `sigaction()`ìœ¼ë¡œ í•¸ë“¤ëŸ¬ ì„¤ì • ê°€ëŠ¥

------

### 7. ê³ ê¸‰: `sigaction()` (ë” ê°•ë ¥í•œ ëŒ€ì•ˆ)

```
#include <signal.h>

int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);
```

- `sigaction()`ì€ `signal()`ë³´ë‹¤ ë” ì•ˆì „í•˜ê³  ê¸°ëŠ¥ì´ ë§ìŒ
- **ì¬ì§„ì… ì•ˆì „**, **ì‹œê·¸ë„ ë¸”ë¡ ì„¤ì •**, **í™•ì¥ ê¸°ëŠ¥ ì§€ì›**

------

### 8. ê²°ë¡  ğŸš€

| ê¸°ëŠ¥          | íŠ¹ì§•                                         |
| ------------- | -------------------------------------------- |
| ì‹œê·¸ë„        | ë¹„ë™ê¸°ì  ì´ë²¤íŠ¸ í†µì§€                         |
| `kill()`      | ì‹œê·¸ë„ ì „ì†¡ (ë‹¤ë¥¸ í”„ë¡œì„¸ìŠ¤ ë˜ëŠ” ê·¸ë£¹ì— ë³´ëƒ„) |
| `signal()`    | ê°„ë‹¨í•œ ì‹œê·¸ë„ í•¸ë“¤ëŸ¬ ì„¤ì •                    |
| `sigaction()` | ê³ ê¸‰ ì‹œê·¸ë„ í•¸ë“¤ë§ (ì¶”ì²œ)                    |

### ì‚¬ìš© ì‚¬ë¡€

 âœ… **í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ ìš”ì²­**
 âœ… **ë¹„ë™ê¸° ì´ë²¤íŠ¸ ì²˜ë¦¬**
 âœ… **IPCì—ì„œ lightweight event í†µì§€**
 âœ… **íƒ€ì´ë¨¸ ê¸°ë°˜ ì´ë²¤íŠ¸ êµ¬í˜„ (SIGALRM)**

## 5.5 UNIX ë„ë©”ì¸ ì†Œì¼“

### 1. ê°œìš”

**UNIX ë„ë©”ì¸ ì†Œì¼“(Unix Domain Socket, UDS)**ì€ **ê°™ì€ ë¨¸ì‹  ë‚´ í”„ë¡œì„¸ìŠ¤ ê°„ í†µì‹ (IPC)**ì„ ìœ„í•œ ê³ ì„±ëŠ¥ í†µì‹  ë°©ë²•ì´ë‹¤.

- í”„ë¡œì„¸ìŠ¤ ê°„ **ìŠ¤íŠ¸ë¦¼ ë˜ëŠ” ë°ì´í„°ê·¸ë¨ ì „ì†¡ ê°€ëŠ¥**
- **TCP/IP ìŠ¤íƒì„ ê±°ì¹˜ì§€ ì•Šê³  ì»¤ë„ ë‚´ë¶€ ë©”ëª¨ë¦¬ë¥¼ í†µí•´ ì§ì ‘ ë°ì´í„° ì „ì†¡** â†’ ë§¤ìš° ë¹ ë¦„
- ì£¼ë¡œ **í´ë¼ì´ì–¸íŠ¸-ì„œë²„ êµ¬ì¡° IPC**ì— ë§ì´ ì‚¬ìš©ë¨ (ex: X ì„œë²„, DBMS, docker, systemd ë‚´ë¶€ ë“±)

#### ì¥ì 

 âœ… ë§¤ìš° ë¹ ë¥¸ IPC
 âœ… ì‹ ë¢°ì„± ìˆëŠ” ìŠ¤íŠ¸ë¦¼ ì œê³µ ê°€ëŠ¥ (SOCK_STREAM)
 âœ… ê°™ì€ í˜¸ìŠ¤íŠ¸ ë‚´ì—ì„œë§Œ ì‚¬ìš© â†’ **ë³´ì•ˆì„± ë†’ìŒ**
 âœ… íŒŒì¼ ì‹œìŠ¤í…œ ë‚´ì˜ ê²½ë¡œë¥¼ í†µí•´ ì†Œì¼“ ì‹ë³„ ê°€ëŠ¥

------

### 2. ì£¼ìš” íŠ¹ì§•

| í•­ëª©      | ë‚´ìš©                                        |
| --------- | ------------------------------------------- |
| ì£¼ì†Œ ì²´ê³„ | íŒŒì¼ ì‹œìŠ¤í…œ ê²½ë¡œ ê¸°ë°˜                       |
| í”„ë¡œí† ì½œ  | SOCK_STREAM, SOCK_DGRAM                     |
| ì†ë„      | TCP/UDPë³´ë‹¤ í›¨ì”¬ ë¹ ë¦„ (ì»¤ë„ ë‚´ ë³µì‚¬ë§Œ ìˆ˜í–‰) |
| ì‚¬ìš© ë²”ìœ„ | ë™ì¼ ë¨¸ì‹  ë‚´ í”„ë¡œì„¸ìŠ¤ ê°„ í†µì‹  ì „ìš©          |

------

### 3. ê´€ë ¨ í—¤ë” ë° êµ¬ì¡°ì²´

```
#include <sys/socket.h>
#include <sys/un.h>
```

- ì£¼ì†Œ êµ¬ì¡°ì²´:

```
struct sockaddr_un {
    sa_family_t sun_family;    // AF_UNIX
    char sun_path[108];        // íŒŒì¼ ê²½ë¡œ (NULL ì¢…ë£Œ ë¬¸ìì—´ ì•„ë‹˜ ì£¼ì˜)
};
```

------

### 4. í”„ë¡œê·¸ë˜ë° ì¸í„°í˜ì´ìŠ¤

| í•¨ìˆ˜                | ìš©ë„                                         |
| ------------------- | -------------------------------------------- |
| `socket()`          | ì†Œì¼“ ìƒì„±                                    |
| `bind()`            | ì„œë²„ ì¸¡ì—ì„œ ì†Œì¼“ì„ íŒŒì¼ ì‹œìŠ¤í…œ ê²½ë¡œì— ë°”ì¸ë”© |
| `listen()`          | ì„œë²„ ì¸¡ì—ì„œ í´ë¼ì´ì–¸íŠ¸ ì—°ê²° ëŒ€ê¸°             |
| `accept()`          | ì„œë²„ ì¸¡ì—ì„œ í´ë¼ì´ì–¸íŠ¸ ì—°ê²° ìˆ˜ë½             |
| `connect()`         | í´ë¼ì´ì–¸íŠ¸ ì¸¡ì—ì„œ ì„œë²„ë¡œ ì—°ê²° ìš”ì²­           |
| `send()` / `recv()` | ë°ì´í„° ì†¡ìˆ˜ì‹                                 |
| `close()`           | ì†Œì¼“ ë‹«ê¸°                                    |
| `unlink()`          | ì†Œì¼“ íŒŒì¼ ì‚­ì œ (ì„œë²„ ì¸¡ì—ì„œ ë°˜ë“œì‹œ í•´ì•¼ í•¨)  |

------

### 5. ì˜ˆì œ: UNIX ë„ë©”ì¸ ì†Œì¼“ ìŠ¤íŠ¸ë¦¼ í†µì‹ 

#### 5.1 ì„œë²„ í”„ë¡œê·¸ë¨ (server.c)

```
#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <unistd.h>

#define SOCKET_PATH "my_socket"

int main() {
    int server_fd, client_fd;
    struct sockaddr_un addr;
    char buffer[128];

    server_fd = socket(AF_UNIX, SOCK_STREAM, 0);
    if (server_fd == -1) {
        perror("socket");
        exit(1);
    }

    // ì†Œì¼“ íŒŒì¼ ì¡´ì¬ ì‹œ ì‚­ì œ
    unlink(SOCKET_PATH);

    addr.sun_family = AF_UNIX;
    strcpy(addr.sun_path, SOCKET_PATH);

    if (bind(server_fd, (struct sockaddr*)&addr, sizeof(addr)) == -1) {
        perror("bind");
        close(server_fd);
        exit(1);
    }

    if (listen(server_fd, 5) == -1) {
        perror("listen");
        close(server_fd);
        exit(1);
    }

    printf("Server waiting for connection...\n");

    client_fd = accept(server_fd, NULL, NULL);
    if (client_fd == -1) {
        perror("accept");
        close(server_fd);
        exit(1);
    }

    printf("Client connected!\n");

    read(client_fd, buffer, sizeof(buffer));
    printf("Received: %s\n", buffer);

    write(client_fd, "Hello from server!", 19);

    close(client_fd);
    close(server_fd);
    unlink(SOCKET_PATH);  // ì†Œì¼“ íŒŒì¼ ì‚­ì œ

    return 0;
}
```

------

#### 5.2 í´ë¼ì´ì–¸íŠ¸ í”„ë¡œê·¸ë¨ (client.c)

```
#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <unistd.h>

#define SOCKET_PATH "my_socket"

int main() {
    int sock_fd;
    struct sockaddr_un addr;
    char buffer[128];

    sock_fd = socket(AF_UNIX, SOCK_STREAM, 0);
    if (sock_fd == -1) {
        perror("socket");
        exit(1);
    }

    addr.sun_family = AF_UNIX;
    strcpy(addr.sun_path, SOCKET_PATH);

    if (connect(sock_fd, (struct sockaddr*)&addr, sizeof(addr)) == -1) {
        perror("connect");
        close(sock_fd);
        exit(1);
    }

    write(sock_fd, "Hello from client!", 19);

    read(sock_fd, buffer, sizeof(buffer));
    printf("Received from server: %s\n", buffer);

    close(sock_fd);

    return 0;
}
```

------

### 6. ì‹¤í–‰ ì ˆì°¨

#### ì»´íŒŒì¼

```
gcc server.c -o server
gcc client.c -o client
```

#### ì‹¤í–‰

1ï¸âƒ£ ì„œë²„ ë¨¼ì € ì‹¤í–‰:

```
./server
```

```
Server waiting for connection...
```

2ï¸âƒ£ í´ë¼ì´ì–¸íŠ¸ ì‹¤í–‰:

```
./client
```

3ï¸âƒ£ ê²°ê³¼ ì˜ˆì‹œ

ì„œë²„ ì¸¡:

```
Client connected!
Received: Hello from client!
```

í´ë¼ì´ì–¸íŠ¸ ì¸¡:

```
Received from server: Hello from server!
```

------

### 7. ì£¼ì˜ ì‚¬í•­

- ì„œë²„ ì¸¡ì—ì„œ ì†Œì¼“ íŒŒì¼(`my_socket`)ì„ **ë°˜ë“œì‹œ unlink()ë¡œ ì‚­ì œ**í•´ì¤˜ì•¼ í•œë‹¤.
  - ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ ë‹¤ìŒì— bind() ì‹œ `Address already in use` ì˜¤ë¥˜ ë°œìƒ.
- **AF_UNIX ì£¼ì†Œ ì²´ê³„**ëŠ” **ë¡œì»¬ íŒŒì¼ ì‹œìŠ¤í…œ ê²½ë¡œ ê¸°ë°˜**ì´ë‹¤ â†’ ì™¸ë¶€ ë„¤íŠ¸ì›Œí¬ë¡œëŠ” í†µì‹  ë¶ˆê°€.
- í†µì‹  ì„±ëŠ¥ì€ TCPë³´ë‹¤ í›¨ì”¬ ë¹ ë¥´ë©°, ëŒ€ê·œëª¨ IPC ì‹œìŠ¤í…œì—ì„œ ë§ì´ ì‚¬ìš©ë¨.

------

### 8. ê²°ë¡  ğŸš€

| ê¸°ëŠ¥             | íŠ¹ì§•                                         |
| ---------------- | -------------------------------------------- |
| UNIX ë„ë©”ì¸ ì†Œì¼“ | ì»¤ë„ ë‚´ë¶€ì—ì„œ ë§¤ìš° ë¹ ë¥¸ í”„ë¡œì„¸ìŠ¤ ê°„ í†µì‹      |
| SOCK_STREAM      | TCPì™€ ê°™ì€ **ì—°ê²°ì§€í–¥ ìŠ¤íŠ¸ë¦¼ í†µì‹ ** ì§€ì›     |
| SOCK_DGRAM       | UDPì™€ ê°™ì€ **ë¹„ì—°ê²° ë°ì´í„°ê·¸ë¨ í†µì‹ **ë„ ê°€ëŠ¥ |
| íŒŒì¼ ê¸°ë°˜ ì£¼ì†Œ   | íŒŒì¼ ì‹œìŠ¤í…œ ê²½ë¡œë¥¼ ì£¼ì†Œë¡œ ì‚¬ìš© (AF_UNIX)     |
| ì‚¬ìš© ì‚¬ë¡€        | DBMS, systemd, Docker, X Window System ë“±    |

# ğŸ“ ì‹¤ìŠµ

## ëª…ëª…ëœ íŒŒì´í”„ë¥¼ í†µí•œ ì±„íŒ… ì‹œë®¬ë ˆì´í„°

### 1. ëª©í‘œ

- ì„œë¡œ ë‹¤ë¥¸ **í„°ë¯¸ë„ 2ê°œì—ì„œ ì±„íŒ…** ê°€ëŠ¥í•˜ë„ë¡ êµ¬í˜„
- **ëª…ëª…ëœ íŒŒì´í”„(`mkfifo`)** ì‚¬ìš©
- A â†’ B ë°©í–¥ìš© FIFO, B â†’ A ë°©í–¥ìš© FIFO ì´ 2ê°œ ì‚¬ìš© (ì–‘ë°©í–¥ í†µì‹  êµ¬í˜„)

êµ¬ì„±:

```
FIFO1 (fifo_AtoB) : A â†’ B ë°©í–¥
FIFO2 (fifo_BtoA) : B â†’ A ë°©í–¥
```

ì–‘ìª½ í”„ë¡œì„¸ìŠ¤ëŠ” ê°ê° **ì“°ê¸°ìš© FIFO, ì½ê¸°ìš© FIFO**ë¥¼ ì‚¬ìš©í•´ì„œ ì±„íŒ… ìˆ˜í–‰.

------

### 2. ì¤€ë¹„ ë‹¨ê³„

#### FIFO ìƒì„±

```
mkfifo fifo_AtoB
mkfifo fifo_BtoA
```

ë˜ëŠ” ì½”ë“œ ë‚´ì—ì„œ `mkfifo()` í˜¸ì¶œë¡œ ìƒì„± ê°€ëŠ¥.

------

### 3. ì½”ë“œ ì˜ˆì œ

#### 3.1 chat_A.c (A ìœ ì €ìš© í”„ë¡œì„¸ìŠ¤)

```
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>

#define FIFO_SEND "fifo_AtoB"
#define FIFO_RECV "fifo_BtoA"

int main() {
    int fd_send, fd_recv;
    char buffer[128];

    // FIFO open
    fd_send = open(FIFO_SEND, O_WRONLY);
    fd_recv = open(FIFO_RECV, O_RDONLY);

    if (fd_send == -1 || fd_recv == -1) {
        perror("open");
        return 1;
    }

    printf("=== Chat A ready ===\n");

    while (1) {
        // ì‚¬ìš©ì ì…ë ¥ â†’ ì „ì†¡
        printf("A: ");
        fgets(buffer, sizeof(buffer), stdin);
        write(fd_send, buffer, strlen(buffer));

        // ìƒëŒ€ë°© ë©”ì‹œì§€ ìˆ˜ì‹ 
        int n = read(fd_recv, buffer, sizeof(buffer) - 1);
        if (n > 0) {
            buffer[n] = '\0';
            printf("B: %s", buffer);
        }
    }

    close(fd_send);
    close(fd_recv);

    return 0;
}
```

------

#### 3.2 chat_B.c (B ìœ ì €ìš© í”„ë¡œì„¸ìŠ¤)

```
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>

#define FIFO_SEND "fifo_BtoA"
#define FIFO_RECV "fifo_AtoB"

int main() {
    int fd_send, fd_recv;
    char buffer[128];

    // FIFO open
    fd_send = open(FIFO_SEND, O_WRONLY);
    fd_recv = open(FIFO_RECV, O_RDONLY);

    if (fd_send == -1 || fd_recv == -1) {
        perror("open");
        return 1;
    }

    printf("=== Chat B ready ===\n");

    while (1) {
        // ì‚¬ìš©ì ì…ë ¥ â†’ ì „ì†¡
        printf("B: ");
        fgets(buffer, sizeof(buffer), stdin);
        write(fd_send, buffer, strlen(buffer));

        // ìƒëŒ€ë°© ë©”ì‹œì§€ ìˆ˜ì‹ 
        int n = read(fd_recv, buffer, sizeof(buffer) - 1);
        if (n > 0) {
            buffer[n] = '\0';
            printf("A: %s", buffer);
        }
    }

    close(fd_send);
    close(fd_recv);

    return 0;
}
```

------

### 4. ì‹¤í–‰ ìˆœì„œ

#### 1ï¸âƒ£ FIFO ì¤€ë¹„

```
mkfifo fifo_AtoB
mkfifo fifo_BtoA
```

#### 2ï¸âƒ£ ì»´íŒŒì¼

```
gcc chat_A.c -o chat_A
gcc chat_B.c -o chat_B
```

#### 3ï¸âƒ£ ì‹¤í–‰ (2ê°œ í„°ë¯¸ë„ ì‚¬ìš©)

- í„°ë¯¸ë„1:

```
./chat_A
```

- í„°ë¯¸ë„2:

```
./chat_B
```

------

### 5. ì‚¬ìš© ì˜ˆì‹œ

```
í„°ë¯¸ë„1:

=== Chat A ready ===
A: Hello B!
B: Hello A!

í„°ë¯¸ë„2:

=== Chat B ready ===
B: Hello A!
A: Hello B!
```

------

### 6. ì£¼ì˜ ì‚¬í•­

- **ì–‘ë°©í–¥ í†µì‹  ì‹œ FIFO 2ê°œ í•„ìš”** â†’ í•œ FIFOëŠ” **ì½ê¸°ìš©**, ë‹¤ë¥¸ í•˜ë‚˜ëŠ” **ì“°ê¸°ìš©**ìœ¼ë¡œ ì‚¬ìš©
- `read()` í˜¸ì¶œì€ **ë¸”ë¡(blocking) í˜¸ì¶œ** â†’ ìƒëŒ€ë°©ì´ ë¨¼ì € writeí•  ë•Œê¹Œì§€ ëŒ€ê¸°
- `fgets()`ëŠ” ê°œí–‰ ë¬¸ìê¹Œì§€ ì…ë ¥ë°›ìœ¼ë¯€ë¡œ ì¶œë ¥ ì‹œ ì¤„ë°”ê¿ˆ ìë™ í¬í•¨ë¨

------

### 7. ì •ë¦¬ ğŸš€

| ìš”ì†Œ            | êµ¬í˜„ ë‚´ìš©                                   |
| --------------- | ------------------------------------------- |
| FIFO ì‚¬ìš©       | `mkfifo()`, `open()`, `read()`, `write()`   |
| ì–‘ë°©í–¥ í†µì‹      | FIFO 2ê°œ í•„ìš” (í•œìª½ì€ write, ë‹¤ë¥¸ìª½ì€ read) |
| ì±„íŒ… ì‹œë®¬ë ˆì´í„° | ê°„ë‹¨í•œ IPC ë°ëª¨ë¡œ ìœ ìš©                      |

ëª…ëª…ëœ íŒŒì´í”„ëŠ” ì´ë ‡ê²Œ ê°„ë‹¨í•œ ì±„íŒ… í”„ë¡œê·¸ë¨ ì™¸ì—ë„:

 âœ… ë¡œê·¸ ì „ì†¡ìš©
 âœ… ì´ë²¤íŠ¸ í†µì§€ìš©
 âœ… ê°€ë²¼ìš´ í´ë¼ì´ì–¸íŠ¸-ì„œë²„ IPC ë“±ì— ë„ë¦¬ ì‚¬ìš©ëœë‹¤.

## ê³µìœ  ë©”ëª¨ë¦¬ ê¸°ë°˜ ê³„ì‚°ê¸°

### 1. ëª©í‘œ

- **Producer í”„ë¡œì„¸ìŠ¤(ì‚¬ìš©ì)**ê°€ ê³„ì‚°í•  ë°ì´í„°ë¥¼ **ê³µìœ  ë©”ëª¨ë¦¬ì— ì“°ê³ **
- **Consumer í”„ë¡œì„¸ìŠ¤(ê³„ì‚°ê¸°)**ê°€ ê³µìœ  ë©”ëª¨ë¦¬ì—ì„œ ë°ì´í„°ë¥¼ ì½ì–´ì„œ ê³„ì‚° í›„ ê²°ê³¼ë¥¼ ë‹¤ì‹œ ê³µìœ  ë©”ëª¨ë¦¬ì— ì”€
- ì‚¬ìš©ìëŠ” ê²°ê³¼ë¥¼ ë‹¤ì‹œ ì½ìŒ

â†’ ì•„ì£¼ ê°„ë‹¨í•œ **ê³„ì‚°ê¸° í´ë¼ì´ì–¸íŠ¸-ì„œë²„ êµ¬ì¡° IPC** ì˜ˆì œ

------

### 2. ì„¤ê³„

#### ê³µìœ  ë©”ëª¨ë¦¬ êµ¬ì¡° ì„¤ê³„

```
struct shm_data {
    int operand1;
    int operand2;
    char operator;
    int result;
    int ready;    // producer â†’ consumer ì „ë‹¬ flag (1: data ready)
    int done;     // consumer â†’ producer ê²°ê³¼ ì™„ë£Œ flag (1: done)
};
```

#### í†µì‹  íë¦„

```
1ï¸âƒ£ Producer (client):
    operand1, operand2, operator â†’ ê³µìœ  ë©”ëª¨ë¦¬ì— ê¸°ë¡
    ready = 1 ì„¤ì • â†’ consumerê°€ ì½ë„ë¡ ì•Œë¦¼
    done == 1 ë  ë•Œê¹Œì§€ ëŒ€ê¸° â†’ ê²°ê³¼ ì½ê¸°

2ï¸âƒ£ Consumer (server):
    ready == 1 ë  ë•Œê¹Œì§€ ëŒ€ê¸° â†’ ë°ì´í„° ì½ê¸°
    ê³„ì‚° í›„ result ê¸°ë¡
    done = 1 ì„¤ì • â†’ producerì— ê²°ê³¼ ì•Œë¦¼
```

------

### 3. ì½”ë“œ ì˜ˆì œ

#### 3.1 shared.h (ê³µí†µ í—¤ë”)

```
#ifndef SHARED_H
#define SHARED_H

#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/types.h>

#define SHM_KEY 0x1234

struct shm_data {
    int operand1;
    int operand2;
    char operator;
    int result;
    int ready;
    int done;
};

#endif
```

------

#### 3.2 Producer (calculator_client.c)

```
#include "shared.h"
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    int shmid = shmget(SHM_KEY, sizeof(struct shm_data), 0666 | IPC_CREAT);
    if (shmid == -1) {
        perror("shmget");
        return 1;
    }

    struct shm_data *data = (struct shm_data *)shmat(shmid, NULL, 0);

    while (1) {
        printf("Enter operand1 operator operand2 (ex: 3 + 5), or 0 q 0 to quit:\n");
        scanf("%d %c %d", &data->operand1, &data->operator, &data->operand2);

        if (data->operator == 'q') {
            data->ready = 0;
            data->done = 0;
            break;
        }

        data->ready = 1;
        data->done = 0;

        // Wait for result
        while (data->done == 0) {
            usleep(1000);  // sleep 1ms
        }

        printf("Result: %d\n", data->result);
    }

    shmdt(data);

    return 0;
}
```

------

#### 3.3 Consumer (calculator_server.c)

```
#include "shared.h"
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    int shmid = shmget(SHM_KEY, sizeof(struct shm_data), 0666 | IPC_CREAT);
    if (shmid == -1) {
        perror("shmget");
        return 1;
    }

    struct shm_data *data = (struct shm_data *)shmat(shmid, NULL, 0);

    printf("Calculator server started.\n");

    while (1) {
        // Wait for data ready
        while (data->ready == 0) {
            usleep(1000);  // sleep 1ms
        }

        if (data->operator == 'q') {
            printf("Quit signal received. Exiting.\n");
            break;
        }

        printf("Received: %d %c %d\n", data->operand1, data->operator, data->operand2);

        switch (data->operator) {
            case '+':
                data->result = data->operand1 + data->operand2;
                break;
            case '-':
                data->result = data->operand1 - data->operand2;
                break;
            case '*':
                data->result = data->operand1 * data->operand2;
                break;
            case '/':
                if (data->operand2 != 0)
                    data->result = data->operand1 / data->operand2;
                else
                    data->result = 0;  // Error handling: divide by zero
                break;
            default:
                data->result = 0;
                break;
        }

        data->ready = 0;
        data->done = 1;
    }

    shmdt(data);
    shmctl(shmid, IPC_RMID, NULL);  // ê³µìœ  ë©”ëª¨ë¦¬ ì‚­ì œ

    return 0;
}
```

------

### 4. ì‹¤í–‰ ìˆœì„œ

#### ì»´íŒŒì¼

```
gcc calculator_client.c -o client
gcc calculator_server.c -o server
```

#### ì‹¤í–‰

- í„°ë¯¸ë„1:

```
./server
```

- í„°ë¯¸ë„2:

```
./client
```

------

#### ì˜ˆì‹œ ë™ì‘

```
í„°ë¯¸ë„2 (client):

Enter operand1 operator operand2 (ex: 3 + 5), or 0 q 0 to quit:
3 + 5
Result: 8

Enter operand1 operator operand2 (ex: 3 + 5), or 0 q 0 to quit:
7 * 9
Result: 63
```

```
í„°ë¯¸ë„1 (server):

Calculator server started.
Received: 3 + 5
Received: 7 * 9
```

------

### 5. ì£¼ì˜ ì‚¬í•­

- **ready / done í”Œë˜ê·¸ë¥¼ ì´ìš©í•œ ë‹¨ìˆœ ë™ê¸°í™”** â†’ ë‹¤ì¤‘ í”„ë¡œì„¸ìŠ¤ í™˜ê²½ì—ì„œëŠ” **Semaphore**ë¡œ ê°œì„  í•„ìš”
- ì´ ì˜ˆì œëŠ” ë§¤ìš° ê¸°ë³¸ êµ¬ì¡° â†’ ì‹¤ì „ì—ì„œëŠ” ë°˜ë“œì‹œ **race condition ë°©ì§€** ê³ ë ¤í•´ì•¼ í•¨
- **shmctl(IPC_RMID)** í˜¸ì¶œë¡œ ì„œë²„ ì¢…ë£Œ ì‹œ ê³µìœ  ë©”ëª¨ë¦¬ ì‚­ì œ ìˆ˜í–‰ (ì•ˆ í•˜ë©´ ì‹œìŠ¤í…œì— ë‚¨ì•„ ìˆìŒ â†’ `ipcs -m`ìœ¼ë¡œ í™•ì¸ ê°€ëŠ¥)

------

### 6. ê²°ë¡  ğŸš€

| êµ¬ì„± ìš”ì†Œ     | ì—­í•                                     |
| ------------- | --------------------------------------- |
| Shared Memory | ê³„ì‚° ë°ì´í„° ë° ê²°ê³¼ ê³µìœ                 |
| ready flag    | producer â†’ consumer ì•Œë¦¼                |
| done flag     | consumer â†’ producer ì•Œë¦¼                |
| ë™ì‘ ë°©ì‹     | clientëŠ” ê³„ì‚° ìš”ì²­ / serverëŠ” ê²°ê³¼ ì‘ë‹µ |

ì´ëŸ° ë°©ì‹ìœ¼ë¡œ **ê³ ì† IPC ê¸°ë°˜ ê³„ì‚°ê¸° ì„œë¹„ìŠ¤**ë¥¼ ì‰½ê²Œ êµ¬í˜„ ê°€ëŠ¥í•˜ë‹¤.

## `signal()`ë¡œ ì¸í„°ëŸ½íŠ¸ ì²˜ë¦¬ í”„ë¡œê·¸ë¨

### 1. ëª©í‘œ

- **ì‹œê·¸ë„ í•¸ë“¤ëŸ¬ë¥¼ ë“±ë¡**í•´ì„œ **Ctrl+C (SIGINT)** ì‹œê·¸ë„ì„ ì²˜ë¦¬
- ê¸°ë³¸ì ìœ¼ë¡œ **Ctrl+C ëˆ„ë¥´ë©´ í”„ë¡œì„¸ìŠ¤ê°€ ì¢…ë£Œ**ë˜ì§€ë§Œ,
   `signal()`ì„ ì‚¬ìš©í•˜ë©´ ìš°ë¦¬ê°€ ì›í•˜ëŠ” ë™ì‘ì„ ìˆ˜í–‰í•  ìˆ˜ ìˆë‹¤.
- ì˜ˆì œì—ì„œëŠ” SIGINT ìˆ˜ì‹  ì‹œ **"ì¸í„°ëŸ½íŠ¸ ë°œìƒ!" ë©”ì‹œì§€ ì¶œë ¥** í›„ ê³„ì† ë™ì‘í•˜ë„ë¡ ë§Œë“¤ì–´ë³¼ê²Œ.

------

### 2. ê¸°ë³¸ êµ¬ì¡°

```
#include <stdio.h>
#include <signal.h>
#include <unistd.h>

void sigint_handler(int signo) {
    printf("\nì¸í„°ëŸ½íŠ¸ ë°œìƒ! (SIGINT)\n");
}

int main() {
    // SIGINT í•¸ë“¤ëŸ¬ ë“±ë¡
    signal(SIGINT, sigint_handler);

    printf("í”„ë¡œê·¸ë¨ ì‹¤í–‰ ì¤‘... (Ctrl+Cë¡œ ì¸í„°ëŸ½íŠ¸ ì‹œê·¸ë„ í…ŒìŠ¤íŠ¸)\n");

    while (1) {
        printf("ì‘ì—… ìˆ˜í–‰ ì¤‘...\n");
        sleep(2);
    }

    return 0;
}
```

------

### 3. ë™ì‘ ì„¤ëª…

- `signal(SIGINT, sigint_handler);` â†’ **SIGINT ë°œìƒ ì‹œ sigint_handler() í˜¸ì¶œí•˜ë„ë¡ ë“±ë¡**
- ì‚¬ìš©ì Ctrl+C ì…ë ¥ â†’ ì»¤ë„ì´ í”„ë¡œì„¸ìŠ¤ì— SIGINT ì „ë‹¬ â†’ sigint_handler() ì‹¤í–‰
- í”„ë¡œê·¸ë¨ì€ ì¢…ë£Œë˜ì§€ ì•Šê³  ê³„ì† ë™ì‘ (ì›ë˜ëŠ” Ctrl+C ëˆ„ë¥´ë©´ ë°”ë¡œ ì¢…ë£Œë¨)

------

### 4. ì‹¤í–‰

#### ì»´íŒŒì¼

```
gcc sigint_example.c -o sigint_example
```

#### ì‹¤í–‰

```
./sigint_example
```

#### í„°ë¯¸ë„ ì¶œë ¥ ì˜ˆì‹œ

```
í”„ë¡œê·¸ë¨ ì‹¤í–‰ ì¤‘... (Ctrl+Cë¡œ ì¸í„°ëŸ½íŠ¸ ì‹œê·¸ë„ í…ŒìŠ¤íŠ¸)
ì‘ì—… ìˆ˜í–‰ ì¤‘...
ì‘ì—… ìˆ˜í–‰ ì¤‘...
ì‘ì—… ìˆ˜í–‰ ì¤‘...

^C
ì¸í„°ëŸ½íŠ¸ ë°œìƒ! (SIGINT)
ì‘ì—… ìˆ˜í–‰ ì¤‘...
ì‘ì—… ìˆ˜í–‰ ì¤‘...
...
```

â†’ Ctrl+C ëˆŒëŸ¬ë„ í”„ë¡œê·¸ë¨ ì¢…ë£Œ ì•ˆ ë¨ â†’ ëŒ€ì‹  í•¸ë“¤ëŸ¬ ë™ì‘

------

### 5. í™•ì¥: ì—¬ëŸ¬ ë²ˆ ì¸í„°ëŸ½íŠ¸ ì‹œ ì¢…ë£Œ

ì˜ˆë¥¼ ë“¤ì–´ **ì²˜ìŒ 2ë²ˆì€ ë©”ì‹œì§€ë§Œ ì¶œë ¥**, **3ë²ˆì§¸ Ctrl+C ì‹œ ì¢…ë£Œ**í•˜ë„ë¡ ë§Œë“¤ ìˆ˜ë„ ìˆë‹¤:

```
#include <stdio.h>
#include <signal.h>
#include <unistd.h>

volatile sig_atomic_t count = 0;

void sigint_handler(int signo) {
    count++;
    printf("\nì¸í„°ëŸ½íŠ¸ ë°œìƒ! (SIGINT), count = %d\n", count);

    if (count >= 3) {
        printf("3ë²ˆ ì¸í„°ëŸ½íŠ¸ ìˆ˜ì‹  â†’ í”„ë¡œê·¸ë¨ ì¢…ë£Œ\n");
        _exit(0);  // ì•ˆì „í•œ ì¢…ë£Œ
    }
}

int main() {
    signal(SIGINT, sigint_handler);

    printf("í”„ë¡œê·¸ë¨ ì‹¤í–‰ ì¤‘... (Ctrl+Cë¡œ ì¸í„°ëŸ½íŠ¸ ì‹œê·¸ë„ í…ŒìŠ¤íŠ¸)\n");

    while (1) {
        printf("ì‘ì—… ìˆ˜í–‰ ì¤‘...\n");
        sleep(2);
    }

    return 0;
}
```

------

#### ë™ì‘ ì˜ˆì‹œ

```
ì‚¬ì‘ì—… ìˆ˜í–‰ ì¤‘...
ì‘ì—… ìˆ˜í–‰ ì¤‘...
^C
ì¸í„°ëŸ½íŠ¸ ë°œìƒ! (SIGINT), count = 1
ì‘ì—… ìˆ˜í–‰ ì¤‘...
^C
ì¸í„°ëŸ½íŠ¸ ë°œìƒ! (SIGINT), count = 2
ì‘ì—… ìˆ˜í–‰ ì¤‘...
^C
ì¸í„°ëŸ½íŠ¸ ë°œìƒ! (SIGINT), count = 3
3ë²ˆ ì¸í„°ëŸ½íŠ¸ ìˆ˜ì‹  â†’ í”„ë¡œê·¸ë¨ ì¢…ë£Œ
```

------

### 6. ì •ë¦¬ ğŸš€

| ìš”ì†Œ        | ì„¤ëª…                                           |
| ----------- | ---------------------------------------------- |
| `signal()`  | ì‹œê·¸ë„ í•¸ë“¤ëŸ¬ ë“±ë¡                             |
| `SIGINT`    | Ctrl+C â†’ SIGINT ë°œìƒ                           |
| í•¸ë“¤ëŸ¬ í•¨ìˆ˜ | ì‹œê·¸ë„ ìˆ˜ì‹  ì‹œ ì»¤ë„ì´ í˜¸ì¶œí•´ì¤Œ                 |
| ì‘ìš©        | ì•ˆì „í•œ ì¸í„°ëŸ½íŠ¸ ì²˜ë¦¬, ì‚¬ìš©ì ì •ì˜ ë™ì‘ ìˆ˜í–‰ ë“± |

**`signal()` + SIGINT í•¸ë“¤ë§**ì€:

 âœ… ì•ˆì „í•œ í”„ë¡œê·¸ë¨ ì¢…ë£Œ
 âœ… í”„ë¡œì„¸ìŠ¤ ìƒíƒœ ì €ì¥ í›„ ì¢…ë£Œ
 âœ… "ì •ì§€ ê¸ˆì§€" ê¸°ëŠ¥ êµ¬í˜„ (ì„ë² ë””ë“œ ë“±ì—ì„œ ë§ì´ ì‚¬ìš©)
 âœ… ì¸í„°ë™í‹°ë¸Œ í”„ë¡œê·¸ë¨ ì œì–´ ë“±ì—ì„œ ë§¤ìš° ìœ ìš©í•˜ë‹¤.