# 11. ì‹¤ì „ í”„ë¡œì íŠ¸

## 11.1 Cë¡œ ë§Œë“  Mini Shell

### ğŸ› ï¸ Mini Shell êµ¬í˜„ ëª©í‘œ

| ëª©í‘œ ê¸°ëŠ¥            | ì„¤ëª…                                           |
| -------------------- | ---------------------------------------------- |
| ëª…ë ¹ì–´ ì…ë ¥ ë°›ê¸°     | ì‚¬ìš©ì ì…ë ¥ ì²˜ë¦¬ (`fgets` ë“± ì‚¬ìš©)             |
| ëª…ë ¹ì–´ íŒŒì‹±          | ê³µë°± ê¸°ì¤€ìœ¼ë¡œ íŒŒë¼ë¯¸í„° ë¶„ë¦¬ (`strtok` ë“± ì‚¬ìš©) |
| ìì‹ í”„ë¡œì„¸ìŠ¤ ìƒì„±   | `fork()`                                       |
| ëª…ë ¹ì–´ ì‹¤í–‰          | `execvp()` ì‚¬ìš©                                |
| ë¶€ëª¨ í”„ë¡œì„¸ìŠ¤ ë™ê¸°í™” | `wait()` ì‚¬ìš©í•´ì„œ ìì‹ ì¢…ë£Œ ê¸°ë‹¤ë¦¬ê¸°           |
| ì¢…ë£Œ ì§€ì›            | `exit` ì…ë ¥ ì‹œ ì…¸ ì¢…ë£Œ                         |

------

### ğŸ“ ì „ì²´ íë¦„

```
Mini Shell ì‹œì‘
â†’ ì‚¬ìš©ì ì…ë ¥ ëŒ€ê¸°
â†’ ëª…ë ¹ì–´ í•´ì„
â†’ í”„ë¡œì„¸ìŠ¤ fork
â†’ ìì‹ì—ì„œ execvpë¡œ ì‹¤í–‰
â†’ ë¶€ëª¨ëŠ” wait()ë¡œ ì¢…ë£Œ ëŒ€ê¸°
â†’ ë°˜ë³µ
```

------

### ğŸ“„ ì „ì²´ ì˜ˆì œ ì½”ë“œ (mini_shell.c)

```
// mini_shell.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>

#define MAX_LINE 1024
#define MAX_ARGS 64

void parse_command(char *line, char **args)
{
    int i = 0;
    args[i] = strtok(line, " \t\r\n");

    while (args[i] != NULL && i < MAX_ARGS - 1)
    {
        i++;
        args[i] = strtok(NULL, " \t\r\n");
    }

    args[i] = NULL;
}

int main()
{
    char line[MAX_LINE];
    char *args[MAX_ARGS];
    pid_t pid;
    int status;

    while (1)
    {
        printf("mini-shell> ");
        fflush(stdout);

        if (fgets(line, sizeof(line), stdin) == NULL)
        {
            break; // EOF (Ctrl+D) ì²˜ë¦¬
        }

        // ì…ë ¥ ê³µë°± ì‹œ ë¬´ì‹œ
        if (line[0] == '\n')
            continue;

        // "exit" ëª…ë ¹ì–´ ì²˜ë¦¬
        if (strncmp(line, "exit", 4) == 0)
        {
            printf("Exiting mini-shell\n");
            break;
        }

        parse_command(line, args);

        pid = fork();

        if (pid < 0)
        {
            perror("fork error");
            continue;
        }
        else if (pid == 0)
        {
            // ìì‹ í”„ë¡œì„¸ìŠ¤
            if (execvp(args[0], args) == -1)
            {
                perror("execvp error");
            }
            exit(EXIT_FAILURE);
        }
        else
        {
            // ë¶€ëª¨ í”„ë¡œì„¸ìŠ¤
            do
            {
                waitpid(pid, &status, WUNTRACED);
            } while (!WIFEXITED(status) && !WIFSIGNALED(status));
        }
    }

    return 0;
}
```

------

### ğŸ—‚ï¸ ë¹Œë“œ ë°©ë²•

```
$ gcc -o mini_shell mini_shell.c
```

### ğŸš€ ì‹¤í–‰

```
$ ./mini_shell
mini-shell> ls -l
... (ls ê²°ê³¼ ì¶œë ¥)

mini-shell> pwd
... (pwd ê²°ê³¼ ì¶œë ¥)

mini-shell> echo Hello World
Hello World

mini-shell> exit
Exiting mini-shell
```

------

### âœ… ì£¼ìš” ê¸°ëŠ¥ ì„¤ëª…

| ê¸°ëŠ¥               | ì½”ë“œ ìœ„ì¹˜                          |
| ------------------ | ---------------------------------- |
| ëª…ë ¹ì–´ ì…ë ¥        | `fgets(line, sizeof(line), stdin)` |
| ëª…ë ¹ì–´ íŒŒì‹±        | `parse_command()` í•¨ìˆ˜             |
| ìì‹ í”„ë¡œì„¸ìŠ¤ ìƒì„± | `fork()`                           |
| ëª…ë ¹ì–´ ì‹¤í–‰        | `execvp()`                         |
| ìì‹ ì¢…ë£Œ ê¸°ë‹¤ë¦¼   | `waitpid()`                        |
| ì¢…ë£Œ ì§€ì›          | `"exit"` ëª…ë ¹ì–´ ì²˜ë¦¬               |

------

### ğŸ” í™•ì¥ ì•„ì´ë””ì–´

| ê¸°ëŠ¥                       | ì„¤ëª…                     |
| -------------------------- | ------------------------ |
| ë°±ê·¸ë¼ìš´ë“œ ì‹¤í–‰ ì§€ì› (`&`) | `ls -l &` í˜•íƒœ ì§€ì›      |
| íŒŒì´í”„ (`                  | `) ì§€ì›                  |
| ë¦¬ë‹¤ì´ë ‰ì…˜ ì§€ì› (`>`, `<`) | `ls > out.txt`           |
| history ê¸°ëŠ¥ ì¶”ê°€          | ì…ë ¥ ê¸°ë¡ ì €ì¥           |
| tab ìë™ì™„ì„±               | readline ë¼ì´ë¸ŒëŸ¬ë¦¬ ì‚¬ìš© |

------

### âœ… Mini Shell ì‹¤ìŠµ ì²´í¬ë¦¬ìŠ¤íŠ¸

-  ëª…ë ¹ì–´ ì…ë ¥ â†’ ì‹¤í–‰ ì„±ê³µ
-  ìì‹ í”„ë¡œì„¸ìŠ¤ â†’ fork/exec ì •ìƒ ë™ì‘ í™•ì¸
-  ë¶€ëª¨ â†’ wait ë¡œ ë™ê¸°í™”
-  exit ëª…ë ¹ì–´ë¡œ ì •ìƒ ì¢…ë£Œ

## 11.2 íŒŒì¼ ë™ê¸°í™” ë„êµ¬

### ğŸ—ºï¸ ì „ì²´ ëª©í‘œ íë¦„

```
[Source Directory] â†’ ë¹„êµ â†’ [Target Directory]

- ìƒˆ íŒŒì¼ â†’ ë³µì‚¬
- ìˆ˜ì •ëœ íŒŒì¼ â†’ ë®ì–´ì“°ê¸°
- ì‚­ì œëœ íŒŒì¼ â†’ (ì˜µì…˜: ì‚­ì œ)
```

------

### ğŸ› ï¸ ê¸°ëŠ¥ ëª…ì„¸

| ê¸°ëŠ¥           | ì„¤ëª…                                    |
| -------------- | --------------------------------------- |
| ë””ë ‰í† ë¦¬ ìˆœíšŒ  | `opendir()`, `readdir()` ì‚¬ìš©           |
| íŒŒì¼ ìƒíƒœ í™•ì¸ | `stat()`, `lstat()` ì‚¬ìš©                |
| íŒŒì¼ ë³µì‚¬      | `read()` / `write()` ê¸°ë°˜ìœ¼ë¡œ ì§ì ‘ êµ¬í˜„ |
| íŒŒì¼ ë¹„êµ ê¸°ì¤€ | `mtime` (ìˆ˜ì • ì‹œê°„)                     |
| ì˜µì…˜           | ì‚­ì œ ë™ê¸°í™”ëŠ” ì˜µì…˜ìœ¼ë¡œ êµ¬í˜„ ê°€ëŠ¥        |

------

### ğŸ“„ ì˜ˆì œ ì½”ë“œ (sync_files.c)

> ì´ë²ˆ ì½”ë“œëŠ” **ë‹¨ì¼ ë””ë ‰í† ë¦¬ ë ˆë²¨**ì—ì„œ ë™ì‘í•˜ëŠ” **ê¸°ë³¸ ë²„ì „**ì´ì•¼.
>  (í•˜ìœ„ ë””ë ‰í† ë¦¬ ì¬ê·€ íƒìƒ‰ì€ ì´í›„ì— ì¶”ê°€ ê°€ëŠ¥)

```
// sync_files.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h>
#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>

#define BUF_SIZE 4096

void copy_file(const char *src_path, const char *dst_path)
{
    int src_fd = open(src_path, O_RDONLY);
    if (src_fd < 0)
    {
        perror("open src");
        return;
    }

    int dst_fd = open(dst_path, O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (dst_fd < 0)
    {
        perror("open dst");
        close(src_fd);
        return;
    }

    char buf[BUF_SIZE];
    ssize_t bytes;

    while ((bytes = read(src_fd, buf, BUF_SIZE)) > 0)
    {
        write(dst_fd, buf, bytes);
    }

    close(src_fd);
    close(dst_fd);

    printf("Copied: %s -> %s\n", src_path, dst_path);
}

void sync_directories(const char *src_dir, const char *dst_dir)
{
    DIR *dir = opendir(src_dir);
    if (!dir)
    {
        perror("opendir");
        return;
    }

    struct dirent *entry;
    while ((entry = readdir(dir)) != NULL)
    {
        // Skip . and ..
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0)
            continue;

        char src_path[1024], dst_path[1024];
        snprintf(src_path, sizeof(src_path), "%s/%s", src_dir, entry->d_name);
        snprintf(dst_path, sizeof(dst_path), "%s/%s", dst_dir, entry->d_name);

        struct stat src_stat, dst_stat;
        if (stat(src_path, &src_stat) < 0)
        {
            perror("stat src");
            continue;
        }

        int dst_exists = (stat(dst_path, &dst_stat) == 0);

        // íŒŒì¼ì¸ ê²½ìš° ì²˜ë¦¬
        if (S_ISREG(src_stat.st_mode))
        {
            int need_copy = 0;

            if (!dst_exists)
            {
                need_copy = 1;
                printf("New file: %s\n", src_path);
            }
            else if (src_stat.st_mtime > dst_stat.st_mtime)
            {
                need_copy = 1;
                printf("Updated file: %s\n", src_path);
            }

            if (need_copy)
            {
                copy_file(src_path, dst_path);
            }
        }
    }

    closedir(dir);
}

int main(int argc, char *argv[])
{
    if (argc != 3)
    {
        fprintf(stderr, "Usage: %s <source_dir> <target_dir>\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    sync_directories(argv[1], argv[2]);

    return 0;
}
```

------

### ğŸ—‚ï¸ ë¹Œë“œ ë°©ë²•

```
$ gcc -o sync_files sync_files.c
```

------

### ğŸš€ ì‹¤í–‰ ì˜ˆì‹œ

```
$ ./sync_files ./source_dir ./target_dir
```

ì¶œë ¥ ì˜ˆì‹œ:

```
New file: ./source_dir/file1.txt
Copied: ./source_dir/file1.txt -> ./target_dir/file1.txt

Updated file: ./source_dir/file2.txt
Copied: ./source_dir/file2.txt -> ./target_dir/file2.txt
```

------

### âœ… ì£¼ìš” ê¸°ëŠ¥ ì„¤ëª…

| ê¸°ëŠ¥           | ì½”ë“œ ìœ„ì¹˜                   |
| -------------- | --------------------------- |
| ë””ë ‰í† ë¦¬ ìˆœíšŒ  | `opendir()`, `readdir()`    |
| íŒŒì¼ ìƒíƒœ í™•ì¸ | `stat()`                    |
| íŒŒì¼ ë³µì‚¬      | `copy_file()`               |
| ë¹„êµ ê¸°ì¤€      | `st_mtime` (ìˆ˜ì • ì‹œê°„) ë¹„êµ |
| ë””ë²„ê·¸ ì¶œë ¥    | `printf` ì‚¬ìš©               |

------

### ğŸ“Œ í™•ì¥ ì•„ì´ë””ì–´

| ê¸°ëŠ¥             | ì„¤ëª…                                    |
| ---------------- | --------------------------------------- |
| ì¬ê·€ ë™ê¸°í™”      | í•˜ìœ„ ë””ë ‰í† ë¦¬ê¹Œì§€ ìë™ ì²˜ë¦¬             |
| ì‚­ì œ ë™ê¸°í™”      | sourceì— ì—†ëŠ” íŒŒì¼ targetì—ì„œ ì‚­ì œ      |
| ë™ê¸°í™” ì˜µì…˜ ì¶”ê°€ | `--delete`, `--verbose` ë“± ì§€ì›         |
| ë‹¤ì¤‘ ìŠ¤ë ˆë“œ ë³µì‚¬ | ëŒ€ìš©ëŸ‰ ë³µì‚¬ ì‹œ ì„±ëŠ¥ í–¥ìƒ                |
| í”„ë¡œê·¸ë ˆìŠ¤ë°”     | ì§„í–‰ ìƒíƒœ í‘œì‹œ (`ncurses` ë“± í™œìš© ê°€ëŠ¥) |

------

### âœ… ì‹¤ìŠµ ì²´í¬ë¦¬ìŠ¤íŠ¸

-  `sync_files.c` ì‘ì„±
-  `gcc` ë¹Œë“œ ì„±ê³µ
-  source/target ë””ë ‰í† ë¦¬ ì¤€ë¹„
-  ìƒˆ íŒŒì¼ ë³µì‚¬ ì„±ê³µ í™•ì¸
-  ìˆ˜ì •ëœ íŒŒì¼ ë®ì–´ì“°ê¸° í™•ì¸

------

### ğŸ ê²°ë¡ 

ì§€ê¸ˆê¹Œì§€ ë§Œë“  ì´ **Mini íŒŒì¼ ë™ê¸°í™” ë„êµ¬**ëŠ”:

 âœ… *ë””ë ‰í† ë¦¬ ìˆœíšŒ*
 âœ… *íŒŒì¼ ë¹„êµ*
 âœ… *ë³µì‚¬ ìˆ˜í–‰*

ì˜ **ê¸°ë³¸ì ì¸ rsync ì›ë¦¬ì˜ í•µì‹¬ êµ¬ì¡°**ë¥¼ ë‹¤ë¤˜ë‹¤ê³  ë³´ë©´ ë¼.

â†’ ì´ ì›ë¦¬ë¥¼ í™•ì¥í•˜ë©´ **ê³ ì„±ëŠ¥ íŒŒì¼ ë°±ì—…ê¸°**, **rsync-like ë™ê¸°í™”ê¸°**, **ë„¤íŠ¸ì›Œí¬ íŒŒì¼ ì „ì†¡ê¸°** ê°™ì€ ê³ ê¸‰ íˆ´ë„ ë§Œë“¤ ìˆ˜ ìˆì–´.

## 11.3 ì“°ë ˆë“œ ê¸°ë°˜ ì••ì¶• ìœ í‹¸ë¦¬í‹°

### ğŸ—ºï¸ êµ¬í˜„ ëª©í‘œ

```
[íŒŒì¼] â†’ ë¸”ë¡ìœ¼ë¡œ ë¶„í•  â†’ ì“°ë ˆë“œë¡œ ë³‘ë ¬ ì••ì¶• â†’ ê²°ê³¼ íŒŒì¼ë¡œ ì €ì¥
```

------

### ê¸°ë³¸ ì„¤ê³„

- ë¸”ë¡ ë‹¨ìœ„ë¡œ íŒŒì¼ ì½ê¸° (`read`)
- ê° ë¸”ë¡ì€ ì“°ë ˆë“œê°€ **ì••ì¶• ì²˜ë¦¬** (ê°„ë‹¨íˆ RLE ë˜ëŠ” zlib ì‚¬ìš© ê°€ëŠ¥)
- ì“°ë ˆë“œ ê²°ê³¼ëŠ” ë©”ì¸ ì“°ë ˆë“œê°€ ëª¨ì•„ì„œ **ì••ì¶• íŒŒì¼**ë¡œ ì¶œë ¥

------

### ğŸ› ï¸ êµ¬í˜„ ë‹¨ê³„

| ë‹¨ê³„                  | ì„¤ëª…                             |
| --------------------- | -------------------------------- |
| 1ï¸âƒ£ ì…ë ¥ íŒŒì¼ ë¸”ë¡ ë¶„í•  | ê³ ì • ë¸”ë¡ í¬ê¸°ë¡œ ìª¼ê°¬            |
| 2ï¸âƒ£ ì“°ë ˆë“œ í’€ êµ¬ì„±      | `pthread_create()` ì‚¬ìš©          |
| 3ï¸âƒ£ ë¸”ë¡ ì••ì¶• ì²˜ë¦¬      | (RLE êµ¬í˜„ or zlib ì‚¬ìš©)          |
| 4ï¸âƒ£ ê²°ê³¼ ëª¨ìŒ           | ì“°ë ˆë“œ ê²°ê³¼ë¥¼ ìˆœì„œ ë³´ì¥í•˜ë©° ì €ì¥ |
| 5ï¸âƒ£ íŒŒì¼ ì¶œë ¥           | ì••ì¶•ëœ ê²°ê³¼ë¬¼ë¡œ ì €ì¥             |

------

### ğŸ“„ ì˜ˆì œ ì½”ë“œ (thread_compress.c)

â†’ ì—¬ê¸°ì„œëŠ” **ë‹¨ìˆœ RLE ì••ì¶• ì•Œê³ ë¦¬ì¦˜**ì„ ì‚¬ìš©í•´ì„œ íë¦„ì„ ì‰½ê²Œ ë³´ì—¬ì¤„ê²Œ.
 (RLE = Run Length Encoding â†’ ë°˜ë³µ ë¬¸ì ìˆ˜ ê¸°ë¡)

------

#### í—¤ë” ë° ì „ì—­ ì„¤ì •

```
// thread_compress.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>

#define BLOCK_SIZE 4096
#define MAX_THREADS 4

typedef struct {
    int block_num;
    size_t input_size;
    char *input_data;
    char *output_data;
    size_t output_size;
} compress_task_t;

void *compress_block(void *arg)
{
    compress_task_t *task = (compress_task_t *)arg;
    char *src = task->input_data;
    char *dst = malloc(task->input_size * 2); // Worst case, no compression

    if (!dst) pthread_exit(NULL);

    size_t out_pos = 0;
    size_t i = 0;

    while (i < task->input_size)
    {
        char ch = src[i];
        size_t count = 1;
        while (i + count < task->input_size && src[i + count] == ch && count < 255)
        {
            count++;
        }
        dst[out_pos++] = ch;
        dst[out_pos++] = count;
        i += count;
    }

    task->output_data = dst;
    task->output_size = out_pos;

    printf("Block %d compressed: %zu bytes -> %zu bytes\n", task->block_num, task->input_size, task->output_size);

    pthread_exit(NULL);
}
```

------

#### ë©”ì¸ í•¨ìˆ˜ (ë¸”ë¡ ë¶„í•  + ì“°ë ˆë“œ ê´€ë¦¬)

```
int main(int argc, char *argv[])
{
    if (argc != 3)
    {
        fprintf(stderr, "Usage: %s <input_file> <output_file>\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    int input_fd = open(argv[1], O_RDONLY);
    if (input_fd < 0)
    {
        perror("open input");
        exit(EXIT_FAILURE);
    }

    int output_fd = open(argv[2], O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (output_fd < 0)
    {
        perror("open output");
        close(input_fd);
        exit(EXIT_FAILURE);
    }

    pthread_t threads[MAX_THREADS];
    compress_task_t tasks[MAX_THREADS];
    int block_num = 0;

    while (1)
    {
        ssize_t bytes_read;
        char *buffer = malloc(BLOCK_SIZE);
        if (!buffer) break;

        bytes_read = read(input_fd, buffer, BLOCK_SIZE);
        if (bytes_read <= 0)
        {
            free(buffer);
            break;
        }

        compress_task_t *task = &tasks[block_num % MAX_THREADS];
        task->block_num = block_num;
        task->input_size = bytes_read;
        task->input_data = buffer;

        pthread_create(&threads[block_num % MAX_THREADS], NULL, compress_block, task);

        // Wait for full batch if MAX_THREADS reached
        if ((block_num + 1) % MAX_THREADS == 0)
        {
            for (int i = 0; i < MAX_THREADS; i++)
            {
                pthread_join(threads[i], NULL);
                write(output_fd, tasks[i].output_data, tasks[i].output_size);
                free(tasks[i].input_data);
                free(tasks[i].output_data);
            }
        }

        block_num++;
    }

    // ë‚¨ì€ ë¸”ë¡ ì²˜ë¦¬
    int remaining = block_num % MAX_THREADS;
    for (int i = 0; i < remaining; i++)
    {
        pthread_join(threads[i], NULL);
        write(output_fd, tasks[i].output_data, tasks[i].output_size);
        free(tasks[i].input_data);
        free(tasks[i].output_data);
    }

    close(input_fd);
    close(output_fd);

    printf("Compression complete.\n");
    return 0;
}
```

------

### ğŸ—‚ï¸ ë¹Œë“œ ë°©ë²•

```
$ gcc -o thread_compress thread_compress.c -lpthread
```

------

### ğŸš€ ì‹¤í–‰ ì˜ˆì‹œ

```
$ ./thread_compress input.txt output.rle
```

ì¶œë ¥ ì˜ˆì‹œ:

```
Block 0 compressed: 4096 bytes -> 1024 bytes
Block 1 compressed: 4096 bytes -> 2048 bytes
...
Compression complete.
```

------

### âœ… ì£¼ìš” ê¸°ëŠ¥ ì„¤ëª…

| ê¸°ëŠ¥        | ì½”ë“œ ìœ„ì¹˜                    |
| ----------- | ---------------------------- |
| ë¸”ë¡ ë¶„í•    | `read()` 4096 byte ë‹¨ìœ„      |
| ì“°ë ˆë“œ ìƒì„± | `pthread_create()`           |
| RLE ì••ì¶•    | `compress_block()`           |
| ê²°ê³¼ ëª¨ìŒ   | `pthread_join()` + `write()` |
| ìì› í•´ì œ   | `free()` ì²˜ë¦¬ ì² ì €           |

------

### ğŸ“Œ í™•ì¥ ì•„ì´ë””ì–´

| ê¸°ëŠ¥                | ì„¤ëª…                                                 |
| ------------------- | ---------------------------------------------------- |
| ê³ ì„±ëŠ¥ ì••ì¶•         | RLE â†’ zlib (`compress()` API)ë¡œ êµì²´ ê°€ëŠ¥            |
| ì¬ê·€ì  ì“°ë ˆë“œ ê´€ë¦¬  | ì“°ë ˆë“œ í’€ êµ¬í˜„ (pthread pool)                        |
| ìˆœì„œ ì•ˆì •ì„± ê°œì„     | block_num ê¸°ì¤€ìœ¼ë¡œ ìˆœì„œ ë³´ì¥ í ì‚¬ìš©                 |
| íŒŒì¼ í—¤ë” ì¶”ê°€      | block ì •ë³´, block size ê¸°ë¡í•´ì„œ ë³µì› ê°€ëŠ¥í•˜ë„ë¡ ì„¤ê³„ |
| ë³‘ë ¬ ì••ì¶• ì„±ëŠ¥ ì¸¡ì • | CPU ì‚¬ìš©ë¥  ë¹„êµ (tasksetìœ¼ë¡œ CPU ì½”ì–´ ê³ ì • í›„ ì¸¡ì •)  |

------

### âœ… ì‹¤ìŠµ ì²´í¬ë¦¬ìŠ¤íŠ¸

-  `thread_compress.c` ì‘ì„±
-  `gcc -lpthread` ë¹Œë“œ ì„±ê³µ
-  ë¸”ë¡ ë‹¨ìœ„ ë©€í‹° ì“°ë ˆë“œ ì••ì¶• í™•ì¸
-  ì“°ë ˆë“œ ë³‘ë ¬ ì²˜ë¦¬ í™•ì¸
-  ì••ì¶•ëœ íŒŒì¼ ì¶œë ¥ ì„±ê³µ

------

### ê²°ë¡ 

ì´ë²ˆ **ì“°ë ˆë“œ ê¸°ë°˜ ì••ì¶• ìœ í‹¸ë¦¬í‹°** ì‹¤ìŠµìœ¼ë¡œ:

 âœ… ë©€í‹° ì“°ë ˆë“œ ê¸°ë°˜ **íŒŒì¼ ì²˜ë¦¬ íŒ¨í„´** í•™ìŠµ
 âœ… `pthread_create()`, `pthread_join()` ì‚¬ìš©
 âœ… ë¸”ë¡ ê¸°ë°˜ ì²˜ë¦¬ ì•Œê³ ë¦¬ì¦˜ ê²½í—˜
 âœ… **ì••ì¶• ì•Œê³ ë¦¬ì¦˜**ì˜ êµ¬ì¡°ì  ì›ë¦¬ ì´í•´

ê¹Œì§€ í•´ë³¼ ìˆ˜ ìˆì—ˆì–´.

------

### ë‹¤ìŒ ì¶”ì²œ íë¦„

 1ï¸âƒ£ **zlib ì‚¬ìš©** â†’ ì‹¤ì „ ì••ì¶•ê¸° ë§Œë“¤ê¸°
 2ï¸âƒ£ **pthread pool ì ìš©** â†’ ì“°ë ˆë“œ ì¬ì‚¬ìš©
 3ï¸âƒ£ **I/O ìµœì í™”** â†’ ë¹„ë™ê¸° I/O ì ìš©
 4ï¸âƒ£ **ì••ì¶•/ë³µì› í”„ë¡œê·¸ë¨ ì„¸íŠ¸** ì™„ì„± (decompress ê¸°ëŠ¥ ì¶”ê°€)

## 11.4 IPC ê¸°ë°˜ ì±„íŒ… ì„œë²„

### ğŸ¯ ëª©í‘œ: IPC ê¸°ë°˜ ì±„íŒ… ì‹œìŠ¤í…œ

- ë°©ì‹: **Named Pipe (FIFO)** ë˜ëŠ” **System V ë©”ì‹œì§€ í**
- êµ¬ì¡°: **ì„œë²„ â†” ì—¬ëŸ¬ í´ë¼ì´ì–¸íŠ¸**
- ê¸°ëŠ¥:
  - í´ë¼ì´ì–¸íŠ¸ â†’ ì„œë²„ë¡œ ë©”ì‹œì§€ ì „ì†¡
  - ì„œë²„ê°€ ëª¨ë“  í´ë¼ì´ì–¸íŠ¸ì— ë©”ì‹œì§€ ë¸Œë¡œë“œìºìŠ¤íŠ¸

### âœ… ì´ë²ˆ êµ¬í˜„ì€: Named Pipe (`mkfifo`) ê¸°ë°˜

------

### ğŸ§± ì „ì²´ êµ¬ì¡° ìš”ì•½

```
[í´ë¼ì´ì–¸íŠ¸ 1] â”         â”Œâ†’ [í´ë¼ì´ì–¸íŠ¸ 1 ìˆ˜ì‹ ]
[í´ë¼ì´ì–¸íŠ¸ 2] â”œâ†’ ì„œë²„ â”€â”¼â†’ [í´ë¼ì´ì–¸íŠ¸ 2 ìˆ˜ì‹ ]
[í´ë¼ì´ì–¸íŠ¸ 3] â”˜         â””â†’ [í´ë¼ì´ì–¸íŠ¸ 3 ìˆ˜ì‹ ]

âœ” í´ë¼ì´ì–¸íŠ¸ â†’ ì„œë²„: /tmp/chat_in
âœ” ì„œë²„ â†’ í´ë¼ì´ì–¸íŠ¸: /tmp/chat_user_<pid>
```

------

### ğŸ“„ 1. ì„œë²„ ì½”ë“œ (chat_server.c)

```
// chat_server.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <dirent.h>

#define SERVER_FIFO "/tmp/chat_in"
#define MAX_MSG 256
#define USER_FIFO_PREFIX "/tmp/chat_user_"

typedef struct {
    pid_t pid;
    char message[MAX_MSG];
} ChatMessage;

void send_to_all_clients(ChatMessage *msg) {
    DIR *dir;
    struct dirent *entry;
    char fifo_path[256];

    dir = opendir("/tmp");
    if (!dir) {
        perror("opendir");
        return;
    }

    while ((entry = readdir(dir)) != NULL) {
        if (strncmp(entry->d_name, "chat_user_", 10) == 0) {
            snprintf(fifo_path, sizeof(fifo_path), "/tmp/%s", entry->d_name);
            int fd = open(fifo_path, O_WRONLY | O_NONBLOCK);
            if (fd >= 0) {
                write(fd, msg, sizeof(ChatMessage));
                close(fd);
            }
        }
    }

    closedir(dir);
}

int main() {
    mkfifo(SERVER_FIFO, 0666);
    int server_fd = open(SERVER_FIFO, O_RDONLY);

    ChatMessage msg;

    printf("ğŸ’¬ Chat server started. Waiting for messages...\n");

    while (1) {
        if (read(server_fd, &msg, sizeof(ChatMessage)) > 0) {
            printf("[PID %d] %s\n", msg.pid, msg.message);
            send_to_all_clients(&msg);
        }
    }

    close(server_fd);
    unlink(SERVER_FIFO);
    return 0;
}
```

------

### ğŸ“„ 2. í´ë¼ì´ì–¸íŠ¸ ì½”ë“œ (chat_client.c)

```
// chat_client.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <pthread.h>

#define SERVER_FIFO "/tmp/chat_in"
#define MAX_MSG 256

typedef struct {
    pid_t pid;
    char message[MAX_MSG];
} ChatMessage;

char user_fifo[256];

void *reader_thread(void *arg) {
    int user_fd = open(user_fifo, O_RDONLY);
    ChatMessage msg;

    while (read(user_fd, &msg, sizeof(ChatMessage)) > 0) {
        printf("[PID %d] %s\n", msg.pid, msg.message);
    }

    return NULL;
}

int main() {
    pid_t pid = getpid();
    snprintf(user_fifo, sizeof(user_fifo), "/tmp/chat_user_%d", pid);
    mkfifo(user_fifo, 0666);

    pthread_t tid;
    pthread_create(&tid, NULL, reader_thread, NULL);

    int server_fd = open(SERVER_FIFO, O_WRONLY);
    ChatMessage msg;
    msg.pid = pid;

    printf("ğŸ’¬ Enter your messages (Ctrl+C to quit):\n");

    while (fgets(msg.message, MAX_MSG, stdin) != NULL) {
        write(server_fd, &msg, sizeof(ChatMessage));
    }

    close(server_fd);
    unlink(user_fifo);
    return 0;
}
```

------

### ğŸ› ï¸ ë¹Œë“œ ë°©ë²•

```
$ gcc -o chat_server chat_server.c
$ gcc -o chat_client chat_client.c -lpthread
```

------

### ğŸš€ ì‹¤í–‰ ë°©ë²•

#### ì„œë²„ ë¨¼ì € ì‹¤í–‰

```
$ ./chat_server
```

#### í´ë¼ì´ì–¸íŠ¸ ì—¬ëŸ¬ ê°œ ì‹¤í–‰ (ë‹¤ë¥¸ í„°ë¯¸ë„ì—ì„œ)

```
$ ./chat_client
```

------

### âœ… ì‹¤ìŠµ ì²´í¬ë¦¬ìŠ¤íŠ¸

-  ì„œë²„ â†’ ë©”ì‹œì§€ ë¸Œë¡œë“œìºìŠ¤íŠ¸ êµ¬í˜„
-  í´ë¼ì´ì–¸íŠ¸ â†’ ì„œë²„ ë©”ì‹œì§€ ì „ì†¡
-  í´ë¼ì´ì–¸íŠ¸ë¼ë¦¬ ë©”ì‹œì§€ ì£¼ê³ ë°›ê¸° ì„±ê³µ
-  Named FIFO ì‚¬ìš© í™•ì¸ (`ls /tmp/chat_*`)
-  ì¢…ë£Œ ì‹œ FIFO ì •ë¦¬ë¨ í™•ì¸

------

### ğŸ“Œ í™•ì¥ ì•„ì´ë””ì–´

| ê¸°ëŠ¥                                                 | ì„¤ëª…                             |
| ---------------------------------------------------- | -------------------------------- |
| ì‚¬ìš©ì ì´ë¦„ ì¶”ê°€                                     | `nickname` í•„ë“œ ì¶”ê°€             |
| í‡´ì¥ ì•Œë¦¼                                            | "exit" ì…ë ¥ ì‹œ ì•Œë¦¼ ë¸Œë¡œë“œìºìŠ¤íŠ¸ |
| ëª…ë ¹ì–´ ì²˜ë¦¬                                          | `/who`, `/exit`, `/help` ë“±      |
| ì±„íŒ… ë¡œê·¸ ì €ì¥                                       | ì„œë²„ì—ì„œ íŒŒì¼ë¡œ ë¡œê·¸ ê¸°ë¡        |
| System V ë©”ì‹œì§€ í or UNIX ë„ë©”ì¸ ì†Œì¼“ ê¸°ë°˜ìœ¼ë¡œ ì „í™˜ | ë” ì•ˆì •ì ì¸ IPC êµ¬í˜„             |

## 11.5 ì»¤ë„ ë¡œê·¸ íŒŒì„œ

### ğŸ¯ êµ¬í˜„ ëª©í‘œ

| ê¸°ëŠ¥           | ì„¤ëª…                                            |
| -------------- | ----------------------------------------------- |
| ë¡œê·¸ íŒŒì¼ ì½ê¸° | `/var/log/kern.log` ë˜ëŠ” `dmesg` ì¶œë ¥ ì €ì¥ íŒŒì¼ |
| í‚¤ì›Œë“œ ê²€ìƒ‰    | ì‚¬ìš©ì ì…ë ¥ í‚¤ì›Œë“œì— í•´ë‹¹í•˜ëŠ” ì¤„ë§Œ ì¶œë ¥         |
| ë¡œê·¸ ë ˆë²¨ ë¶„ì„ | KERN_xxx ë ˆë²¨ë³„ í†µê³„ ì¶œë ¥                       |
| ì˜µì…˜           | ì‹¤ì‹œê°„ tail -f ìŠ¤íƒ€ì¼ êµ¬í˜„ ê°€ëŠ¥                 |

------

### ğŸ—ºï¸ êµ¬í˜„ ì„¤ê³„ íë¦„

```
1ï¸âƒ£ ë¡œê·¸ íŒŒì¼ ì—´ê¸°
2ï¸âƒ£ í•œ ì¤„ì”© ì½ê¸° â†’ `fgets()`
3ï¸âƒ£ í‚¤ì›Œë“œ í¬í•¨ ì—¬ë¶€ ê²€ì‚¬ â†’ `strstr()`
4ï¸âƒ£ ë ˆë²¨ë³„ ì¹´ìš´íŠ¸ ë¶„ì„ (ì„ íƒ)
5ï¸âƒ£ ê²°ê³¼ ì¶œë ¥
```

------

### ğŸ“„ ê¸°ë³¸ ì˜ˆì œ ì½”ë“œ (kernel_log_parser.c)

```
// kernel_log_parser.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_LINE 1024

void print_usage(const char *progname) {
    printf("Usage: %s <log_file> <keyword>\n", progname);
}

void parse_log(const char *log_file, const char *keyword) {
    FILE *fp = fopen(log_file, "r");
    if (!fp) {
        perror("fopen");
        exit(EXIT_FAILURE);
    }

    char line[MAX_LINE];
    int match_count = 0;

    while (fgets(line, sizeof(line), fp) != NULL) {
        if (strstr(line, keyword)) {
            printf("%s", line);
            match_count++;
        }
    }

    fclose(fp);

    printf("\nTotal matched lines: %d\n", match_count);
}

int main(int argc, char *argv[]) {
    if (argc != 3) {
        print_usage(argv[0]);
        exit(EXIT_FAILURE);
    }

    const char *log_file = argv[1];
    const char *keyword = argv[2];

    parse_log(log_file, keyword);

    return 0;
}
```

------

### ğŸ—‚ï¸ ë¹Œë“œ ë°©ë²•

```
$ gcc -o kernel_log_parser kernel_log_parser.c
```

------

### ğŸš€ ì‹¤í–‰ ì˜ˆì‹œ

```
# dmesg ë¡œê·¸ íŒŒì¼ë¡œ ì €ì¥
$ dmesg > dmesg.log

# íŠ¹ì • í‚¤ì›Œë“œ ê²€ìƒ‰
$ ./kernel_log_parser dmesg.log USB
```

ì¶œë ¥ ì˜ˆì‹œ:

```
[    2.345678] usb 1-1: new high-speed USB device number 2 using xhci_hcd
[    2.456789] usb 1-1: Manufacturer: Generic USB Device
...

Total matched lines: 5
```

------

### âœ… ì£¼ìš” ê¸°ëŠ¥ ì„¤ëª…

| ê¸°ëŠ¥           | ì½”ë“œ ìœ„ì¹˜               |
| -------------- | ----------------------- |
| ë¡œê·¸ íŒŒì¼ ì—´ê¸° | `fopen()`               |
| í•œ ì¤„ì”© ì½ê¸°   | `fgets()`               |
| í‚¤ì›Œë“œ ê²€ìƒ‰    | `strstr()`              |
| ë§¤ì¹­ ì¤„ ì¶œë ¥   | `printf()`              |
| ë§¤ì¹­ ì¹´ìš´íŠ¸    | `match_count` ë³€ìˆ˜ ì‚¬ìš© |

------

### ğŸ“Œ í™•ì¥ ì•„ì´ë””ì–´

| ê¸°ëŠ¥                  | ì„¤ëª…                                     |
| --------------------- | ---------------------------------------- |
| ë¡œê·¸ ë ˆë²¨ í†µê³„ ì¶œë ¥   | KERN_ERR, KERN_WARNING ë“± í†µê³„           |
| ì‹¤ì‹œê°„ tail -f êµ¬í˜„   | `inotify` ë˜ëŠ” `sleep+fseek` ì‚¬ìš©        |
| ë‹¤ì¤‘ í‚¤ì›Œë“œ ê²€ìƒ‰ ì§€ì› | `OR` ê²€ìƒ‰ ê¸°ëŠ¥ ì¶”ê°€                      |
| ìƒ‰ìƒ ì¶œë ¥             | `ANSI escape code` ë¡œ KERN_ERRëŠ” ë¹¨ê°• ë“± |
| ë¡œê·¸ ë‚ ì§œë³„ í•„í„°ë§    | `grep` + `strptime()` í™œìš© ê°€ëŠ¥          |

------

### âœ… ì‹¤ìŠµ ì²´í¬ë¦¬ìŠ¤íŠ¸

-  `kernel_log_parser.c` ì‘ì„±
-  `gcc` ë¹Œë“œ ì„±ê³µ
-  ë¡œê·¸ íŒŒì¼ ì¤€ë¹„ (`dmesg > dmesg.log` ë“±)
-  í‚¤ì›Œë“œ ê²€ìƒ‰ ì •ìƒ ë™ì‘ í™•ì¸
-  ë§¤ì¹­ ë¼ì¸ ì¶œë ¥ ë° ì¹´ìš´íŠ¸ í™•ì¸

------

### ğŸš€ ë°œì „ ë°©í–¥

ë‹¤ìŒ ë‹¨ê³„ë¡œëŠ” â†’ **ë ˆë²¨ë³„ í†µê³„ ì¶œë ¥ ê¸°ëŠ¥** ì¶”ê°€í•´ë³¼ ìˆ˜ ìˆì–´.
 ì˜ˆë¥¼ ë“¤ì–´:

```
KERN_ERR: 5 lines
KERN_WARNING: 8 lines
KERN_INFO: 20 lines
```

ì´ëŸ° ì¶œë ¥ ì¶”ê°€í•˜ë©´ **ì»¤ë„ ë¡œê·¸ ìƒíƒœ ë¶„ì„ê¸°** ìˆ˜ì¤€ê¹Œì§€ ì˜¬ë¼ê°ˆ ìˆ˜ ìˆì–´.